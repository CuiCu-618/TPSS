/*
 * stokes_integrator.h
 *
 *  Created on: May 19, 2020
 *      Author: witte
 */

#ifndef APPS_STOKESINTEGRATOR_H_
#define APPS_STOKESINTEGRATOR_H_

#include <deal.II/base/subscriptor.h>

#include <deal.II/integrators/laplace.h>
#include <deal.II/meshworker/dof_info.h>
#include <deal.II/meshworker/integration_info.h>
#include <deal.II/meshworker/loop.h>


#include "solvers_and_preconditioners/TPSS/fd_evaluation.h"
#include "solvers_and_preconditioners/TPSS/matrix_utilities.h"
#include "solvers_and_preconditioners/TPSS/tensor_product_matrix.h"


#include "biharmonic_integrator.h"
#include "common_integrator.h"
#include "equation_data.h"
#include "laplace_integrator.h"

namespace Stokes
{
using namespace dealii;

constexpr int
n_q_points_1d_impl(const int fe_degree_v, const TPSS::DoFLayout dof_layout_v)
{
  return fe_degree_v + 1 + (dof_layout_v == TPSS::DoFLayout::RT ? 1 : 0);
}

/**
 * Computes transformation matrices that map velocity shape functions
 * (represented by @p fe_v) to "orthogonal" velocity shape functions. The
 * latter form a basis for the L^2-complement of the divergence-free velocity
 * subspace, which is spanned by stream shape functions. Two matrices are
 * returned, the first maps "orthogonal" shape functions being dual to the
 * pressure gradient, the latter maps functions being dual to the constant
 * pressure mode, thus @p fe_p should be a Legendre-type finite element.
 */
template<int dim>
std::array<FullMatrix<double>, 2>
compute_divfreeorth_shape_functions(const FiniteElement<dim> & fe_v,
                                    const FiniteElement<dim> & fe_p)
{
  AssertDimension(dim, 2U);

  const MappingQGeneric<dim> mapping(1);

  const auto         n_dofs_per_cell_v = fe_v.dofs_per_cell;
  const auto         n_dofs_per_cell_p = fe_p.dofs_per_cell;
  const auto         n_faces_per_cell  = GeometryInfo<dim>::faces_per_cell;
  const auto         n_nodes_gradp     = n_dofs_per_cell_p - 1;
  const unsigned int n_q_points_1d     = fe_v.tensor_degree() + 1;

  Triangulation<dim> unit_triangulation(Triangulation<dim>::maximum_smoothing);
  {
    MeshParameter mesh_prms;
    mesh_prms.geometry_variant = MeshParameter::GeometryVariant::Cube;
    mesh_prms.n_refinements    = 0U;
    mesh_prms.n_repetitions    = 1U;
    create_mesh(unit_triangulation, mesh_prms);
    AssertDimension(unit_triangulation.n_active_cells(), 1U);
  }

  DoFHandler<dim> unit_dofh_v;
  DoFHandler<dim> unit_dofh_p;
  unit_dofh_v.initialize(unit_triangulation, fe_v);
  unit_dofh_p.initialize(unit_triangulation, fe_p);

  /// Caching both "interior" and "face" node functional evaluations
  LAPACKFullMatrix<double> node_values_all;
  node_values_all.reinit(n_nodes_gradp + n_faces_per_cell, n_dofs_per_cell_v);

  /// Evaluate each velocity shape function (so far Raviart-Thomas elements) for
  /// each "interior" node functional. Functionals are generated by the gradient
  /// of all "pressure" shape functions except the constant mode.
  {
    QGauss<dim>       quad(n_q_points_1d);
    const UpdateFlags update_flags =
      update_values | update_gradients | update_quadrature_points | update_JxW_values;

    FEValues<dim> fe_values_p(mapping, fe_p, quad, update_flags);
    fe_values_p.reinit(unit_dofh_p.begin_active()); // one reference cell

    FEValues<dim> fe_values_v(mapping, fe_v, quad, update_flags);
    fe_values_v.reinit(unit_dofh_v.begin_active()); // one reference cell

    /// Node functionals generated by grad p.
    const auto interior_node_functional = [&](const unsigned int   node_index_p,
                                              const Vector<double> velocity) {
      const auto n_q_points  = fe_values_p.n_quadrature_points;
      const auto dof_index_p = node_index_p + 1; // skip constant mode
      AssertIndexRange(dof_index_p, fe_values_p.dofs_per_cell);
      AssertDimension(velocity.size(), fe_values_v.dofs_per_cell);

      const auto & compute_v_q = [&](const unsigned int q) {
        Tensor<1, dim> value;
        for(unsigned int j = 0; j < n_dofs_per_cell_v; ++j)
          value += velocity[j] * MW::compute_vvalue(fe_values_v, j, q);
        return value;
      };

      double node_value = 0.;
      for(unsigned int q = 0; q < n_q_points; ++q)
      {
        const Tensor<1, dim> & grad_q = fe_values_p.shape_grad(dof_index_p, q);
        const Tensor<1, dim> & v_q    = compute_v_q(q);
        const auto &           dx     = fe_values_p.JxW(q);

        node_value += v_q * grad_q * dx;
      }

      return node_value;
    };

    LAPACKFullMatrix<double> node_values(n_nodes_gradp, n_dofs_per_cell_v);
    for(auto i = 0U; i < node_values.m(); ++i)   // node functionals
      for(auto j = 0U; j < node_values.n(); ++j) // RT shape funcs
      {
        Vector<double> phi_j(n_dofs_per_cell_v);
        phi_j[j]          = 1.;
        node_values(i, j) = interior_node_functional(i, phi_j);
      }

    /// DEBUG
    // std::cout << "node value weights (interior): " << std::endl;
    // remove_noise_from_matrix(node_values);
    // node_values.print_formatted(std::cout);

    for(auto i = 0U; i < node_values.m(); ++i)
      for(auto j = 0U; j < node_values.n(); ++j)
        node_values_all(i, j) = node_values(i, j);
  }

  /// Evaluate each velocity shape function (currently assuming Raviart-Thomas
  /// elements) for each "face" node functional generated by the constant
  /// "pressure" function each.
  {
    QGauss<dim - 1>   quad(n_q_points_1d);
    const UpdateFlags update_flags =
      update_values | update_normal_vectors | update_quadrature_points | update_JxW_values;

    FEFaceValues<dim> fe_values_v(mapping, fe_v, quad, update_flags);

    const auto face_node_functional = [&](const unsigned int face_no, const Vector<double> v) {
      const auto & unit_cell = unit_dofh_v.begin_active(); // one reference cell
      fe_values_v.reinit(unit_cell, face_no);

      const auto   n_q_points = fe_values_v.n_quadrature_points;
      const auto & normals    = fe_values_v.get_normal_vectors();
      AssertDimension(v.size(), fe_values_v.dofs_per_cell);

      const auto & compute_v_q = [&](const unsigned int q) {
        Tensor<1, dim> value;
        for(unsigned int j = 0; j < n_dofs_per_cell_v; ++j)
          value += v[j] * MW::compute_vvalue(fe_values_v, j, q);
        return value;
      };

      double node_value = 0.;
      for(unsigned int q = 0; q < n_q_points; ++q)
      {
        const double           orientation = GeometryInfo<dim>::unit_normal_orientation[face_no];
        const Tensor<1, dim> & n_q         = orientation * normals[q];
        const Tensor<1, dim> & v_q         = compute_v_q(q);
        const auto &           dx          = fe_values_v.JxW(q);

        node_value += v_q * n_q * dx;
      }

      return node_value;
    };

    LAPACKFullMatrix<double> node_values(n_faces_per_cell, n_dofs_per_cell_v);
    for(auto i = 0U; i < node_values.m(); ++i)   // node functionals
      for(auto j = 0U; j < node_values.n(); ++j) // face shape funcs
      {
        Vector<double> phi_j(n_dofs_per_cell_v);
        phi_j[j]          = 1.;
        node_values(i, j) = face_node_functional(/*face_no*/ i, phi_j);
      }

    for(auto i = 0U; i < node_values.m(); ++i)
      for(auto j = 0U; j < node_values.n(); ++j)
        node_values_all(n_nodes_gradp + i, j) = node_values(i, j);
  }

  /// Finally, computing the inverse weights and afterwards transposing results
  /// in the transformation matrix from original velocity shape functions (so
  /// far Raviart-Thomas elements) to non-div-free velocity test functions
  LAPACKFullMatrix<double> trafomatrix_all;
  trafomatrix_all.reinit(node_values_all.m(), node_values_all.n());
  const auto & [V, invSigma, UT]   = compute_inverse_svd(node_values_all);
  const auto & inverse_node_values = merge_lapack_decomposition(V, invSigma, UT);
  inverse_node_values.transpose(trafomatrix_all);

  /// DEBUG
  // std::cout << "velocity to div-free orth.: " << std::endl;
  // remove_noise_from_matrix(trafomatrix_all);
  // trafomatrix_all.print_formatted(std::cout);

  std::array<FullMatrix<double>, 2> shape_function_weights;
  auto & [trafomatrix_velocity_to_gradp, trafomatrix_velocity_to_constp] = shape_function_weights;

  /// test functions associated with the interior (generated by pressure gradients)
  trafomatrix_velocity_to_gradp.reinit(n_nodes_gradp, n_dofs_per_cell_v);
  for(auto i = 0U; i < trafomatrix_velocity_to_gradp.m(); ++i)
    for(auto j = 0U; j < trafomatrix_velocity_to_gradp.n(); ++j)
      trafomatrix_velocity_to_gradp(i, j) = trafomatrix_all(i, j);

  /// test functions associated with each facet (generated by the constant pressure)
  trafomatrix_velocity_to_constp.reinit(n_faces_per_cell, n_dofs_per_cell_v);
  for(auto i = 0U; i < trafomatrix_velocity_to_constp.m(); ++i)
    for(auto j = 0U; j < trafomatrix_velocity_to_constp.n(); ++j)
      trafomatrix_velocity_to_constp(i, j) = trafomatrix_all(n_nodes_gradp + i, j);

  /// DEBUG
  /// Display L2 orthogonal velocity functions \tilde{v}_i
  // for(auto i = 0U; i < trafomatrix_all.m(); ++i)
  // {
  //   Vector<double> phi_i(trafomatrix_all.n());
  //   for(auto j = 0U; j < trafomatrix_all.n(); ++j)
  //     phi_i(j) = trafomatrix_all(i, j);

  //   std::vector<std::string> names(dim, "shape_function");
  //   const std::string        prefix         = "unit_divfreeorth_velocities";
  //   const std::string        suffix         = "phi" + Utilities::int_to_string(i, 3);
  //   const auto               n_subdivisions = 10U;
  //   std::vector<DataComponentInterpretation::DataComponentInterpretation>
  //     data_component_interpretation(dim,
  //     DataComponentInterpretation::component_is_part_of_vector);
  //   visualize_dof_vector(unit_dofh_v,
  //                        phi_i,
  //                        names,
  //                        prefix,
  //                        suffix,
  //                        n_subdivisions,
  //                        data_component_interpretation,
  //                        mapping);
  // }

  return shape_function_weights;
}



/**
 * Computes the prolongation matrix mapping stream function coefficients
 * (represented by @p fe_sf) to velocity coefficients (represented by @p fe_v)
 * on a single reference cell.
 */
template<int dim>
FullMatrix<double>
compute_unit_prolongation_stream(const FiniteElement<dim> & fe_sf, const FiniteElement<dim> & fe_v)
{
  const auto n_dofs_per_cell_v  = fe_v.dofs_per_cell;
  const auto n_dofs_per_cell_sf = fe_sf.dofs_per_cell;

  const auto & gsupport_points = fe_v.get_generalized_support_points();

  FullMatrix<double> node_value_matrix;
  node_value_matrix.reinit(n_dofs_per_cell_v, n_dofs_per_cell_sf);

  std::vector<double> node_values(n_dofs_per_cell_v);
  for(auto j = 0U; j < n_dofs_per_cell_sf; ++j)
  {
    std::vector<Vector<double>> curls_phi_j;
    std::transform(gsupport_points.cbegin(),
                   gsupport_points.cend(),
                   std::back_inserter(curls_phi_j),
                   [&](const auto & x_q) {
                     Vector<double> v(dim);
                     const auto &   vcurl_phi_j = ::MW::compute_vcurl(fe_sf, j, x_q);
                     for(auto comp = 0U; comp < dim; ++comp)
                       v[comp] = vcurl_phi_j[comp];
                     return v;
                   });
    std::fill(node_values.begin(), node_values.end(), 0.);
    fe_v.convert_generalized_support_point_values_to_dof_values(curls_phi_j, node_values);
    for(auto i = 0U; i < n_dofs_per_cell_v; ++i)
      node_value_matrix(i, j) = node_values[i];
  }

  /// DEBUG
  // std::cout << "unit prolongation: " << std::endl;
  // remove_noise_from_matrix(node_value_matrix);
  // node_value_matrix.print_formatted(std::cout);

  return node_value_matrix;
}



/**
 * Represents the prolongation operator of stream functions for a single
 * uniform vertex patch of the unit hyper-cube. "Homogeneous" boundary
 * conditions are taken into consideration, in other words, all degrees of freedom
 * belonging to the boundary are set to zero.
 */
template<int dim, typename Number>
struct ProlongationStream
{
  ProlongationStream(const FiniteElement<dim> & fe_sf, const FiniteElement<dim> & fe_v)
  {
    using namespace TPSS;

    const unsigned int n_q_points_1d = fe_v.tensor_degree() + 1;

    Triangulation<dim> unit_triangulation(Triangulation<dim>::maximum_smoothing);
    {
      MeshParameter mesh_prms;
      mesh_prms.geometry_variant = MeshParameter::GeometryVariant::Cube;
      mesh_prms.n_refinements    = 0U;
      mesh_prms.n_repetitions    = 2U;
      create_mesh(unit_triangulation, mesh_prms);
      AssertDimension(unit_triangulation.n_active_cells(), 1 << dim);
    }

    DoFHandler<dim> dofh_sf;
    dofh_sf.initialize(unit_triangulation, fe_sf);
    dofh_sf.distribute_mg_dofs();

    PatchInfo<dim> patch_info;
    {
      using additional_data_type = typename PatchInfo<dim>::AdditionalData;
      additional_data_type additional_data;
      additional_data.patch_variant    = PatchVariant::vertex;
      additional_data.smoother_variant = SmootherVariant::additive;
      additional_data.level            = 0;
      patch_info.initialize(&dofh_sf, additional_data);
      PatchWorker<dim, double>{patch_info};
    }

    QGauss<1> quad_1d(n_q_points_1d);

    dealii::internal::MatrixFreeFunctions::ShapeInfo<VectorizedArray<double>> shape_info;
    shape_info.reinit(quad_1d, fe_sf);

    DoFInfo<dim, double> dof_info;
    {
      using additional_data_type = typename DoFInfo<dim, double>::AdditionalData;
      additional_data_type additional_data;
      additional_data.level = 0;
      dof_info.initialize(&dofh_sf, &patch_info, &shape_info, additional_data);
    }

    DoFHandler<dim> dofh_v;
    dofh_v.initialize(unit_triangulation, fe_v);
    dofh_v.distribute_mg_dofs();

    dealii::internal::MatrixFreeFunctions::ShapeInfo<VectorizedArray<double>> shape_info_v;
    shape_info_v.reinit(quad_1d, fe_v);

    DoFInfo<dim, double> dof_info_v;
    {
      using additional_data_type = typename DoFInfo<dim, double>::AdditionalData;
      additional_data_type additional_data;
      additional_data.level = 0;
      dof_info_v.initialize(&dofh_v, &patch_info, &shape_info_v, additional_data);
    }

    PatchTransfer<dim, double> patch_transfer_sf(dof_info);
    PatchTransfer<dim, double> patch_transfer_v(dof_info_v);

    const FullMatrix<double> & cell_prolongation_matrix =
      compute_unit_prolongation_stream(fe_sf, fe_v);

    unsigned int patch_index = 0;
    unsigned int lane        = 0;

    patch_transfer_sf.reinit(patch_index);
    patch_transfer_v.reinit(patch_index);

    const auto & g2l_sf = patch_transfer_sf.get_global_to_local_dof_indices(lane);
    const auto & g2l_v  = patch_transfer_v.get_global_to_local_dof_indices(lane);

    const auto g2l_if_impl = [&](const auto & map, const types::global_dof_index i) {
      const auto it = map.find(i);
      return it == map.end() ? numbers::invalid_unsigned_int : it->second;
    };

    const auto & g2l_if_sf = [&](const types::global_dof_index i) {
      return g2l_if_impl(g2l_sf, i);
    };

    const auto & g2l_if_v = [&](const types::global_dof_index i) { return g2l_if_impl(g2l_v, i); };

    const unsigned int n_patch_dofs_sf = g2l_sf.size();
    const unsigned int n_patch_dofs_v  = g2l_v.size();

    auto & this_matrix = prolongation_matrix.as_table();
    this_matrix.reinit(n_patch_dofs_v, n_patch_dofs_sf);

    const auto & cell_collection_sf =
      patch_transfer_sf.get_patch_dof_worker().get_cell_collection(patch_index, lane);
    const auto & cell_collection_v =
      patch_transfer_v.get_patch_dof_worker().get_cell_collection(patch_index, lane);

    std::vector<types::global_dof_index> global_dof_indices_sf(cell_prolongation_matrix.n());
    std::vector<types::global_dof_index> global_dof_indices_v(cell_prolongation_matrix.m());

    for(auto cell_no = 0U; cell_no < cell_collection_sf.size(); ++cell_no)
    {
      const auto & cell_sf = cell_collection_sf[cell_no];
      const auto & cell_v  = cell_collection_v[cell_no];

      cell_sf->get_active_or_mg_dof_indices(global_dof_indices_sf);
      cell_v->get_active_or_mg_dof_indices(global_dof_indices_v);

      for(auto ci = 0U; ci < global_dof_indices_v.size(); ++ci)
      {
        const auto         i  = global_dof_indices_v[ci];
        const unsigned int ii = g2l_if_v(i);
        if(ii != numbers::invalid_unsigned_int)
        {
          for(auto cj = 0U; cj < global_dof_indices_sf.size(); ++cj)
          {
            const auto         j  = global_dof_indices_sf[cj];
            const unsigned int jj = g2l_if_sf(j);
            if(jj != numbers::invalid_unsigned_int)
              this_matrix(ii, jj) = cell_prolongation_matrix(ci, cj);
          }
        }
      }
    }
  }

  /**
   * Prolongates stream function coefficients to velocity coefficients.
   */
  void
  prolongate(const ArrayView<VectorizedArray<Number>> &       dst_view,
             const ArrayView<const VectorizedArray<Number>> & src_view) const
  {
    return prolongation_matrix.vmult(dst_view, src_view);
  }

  /**
   * Restricts dual velocity coefficients to dual stream function
   * coefficients. The dual restriction is simply the transpose prolongation.
   */
  void
  dual_restrict(const ArrayView<VectorizedArray<Number>> &       dst_view,
                const ArrayView<const VectorizedArray<Number>> & src_view) const
  {
    return prolongation_matrix.Tvmult(dst_view, src_view);
  }

  MatrixAsTable<VectorizedArray<Number>> prolongation_matrix;
};



template<int dim, typename Number>
struct ProlongationDivFreeOrth
{
  ProlongationDivFreeOrth(const FiniteElement<dim> & fe_v, const FiniteElement<dim> & fe_p)
  {
    using namespace TPSS;

    const auto & [velocity_to_dual_gradp, velocity_to_dual_constp] =
      compute_divfreeorth_shape_functions(fe_v, fe_p);

    unit_prolongation_matrix.reinit(velocity_to_dual_gradp.n(), velocity_to_dual_gradp.m());
    for(auto i = 0U; i < unit_prolongation_matrix.m(); ++i)
      for(auto j = 0U; j < unit_prolongation_matrix.n(); ++j)
        unit_prolongation_matrix(i, j) = velocity_to_dual_gradp(j, i);

    unit_prolongation_matrix_faces.reinit(velocity_to_dual_constp.n(), velocity_to_dual_constp.m());
    for(auto i = 0U; i < unit_prolongation_matrix_faces.m(); ++i)
      for(auto j = 0U; j < unit_prolongation_matrix_faces.n(); ++j)
        unit_prolongation_matrix_faces(i, j) = velocity_to_dual_constp(j, i);
  }

  Table<2, VectorizedArray<Number>> unit_prolongation_matrix;
  Table<2, VectorizedArray<Number>> unit_prolongation_matrix_faces;
};



/**
 * Linear operators associated to the SIPG formulation (symmetric gradient) for
 * the stokes velocity with heterogeneous Dirichlet boundary conditions
 *
 * (MW) MeshWorker
 * (FD) FastDiagonalization
 */
namespace Velocity
{
namespace SIPG
{
using ::Nitsche::compute_penalty_impl;


namespace MW
{
using ::MW::compute_grad;

using ::MW::compute_symgrad;

using ::MW::compute_average_grad;

using ::MW::compute_average_symgrad;

using ::MW::compute_vvalue;

using ::MW::compute_vvalue_tangential;

using ::MW::compute_vjump;

using ::MW::compute_vjump_cross_normal;

using ::MW::compute_average_symgrad_tangential;

using ::MW::compute_vjump_tangential;

using ::MW::compute_vjump_cross_normal_tangential;

using ::MW::compute_vcurl;



template<int dim, bool with_shape_to_test>
struct ScratchDataSelector
{
  // empty. see specs.
};

template<int dim>
struct ScratchDataSelector<dim, false>
{
  using type = typename ::MW::StreamFunction::ScratchData<dim>;
};

template<int dim>
struct ScratchDataSelector<dim, true>
{
  using type = typename ::MW::TestFunction::ScratchData<dim>;
};

template<int dim, bool with_shape_to_test = false>
using ScratchData = typename ScratchDataSelector<dim, with_shape_to_test>::type;

using ::MW::DoF::CopyData;



using ::MW::StreamFunction::compute_grad;

using ::MW::StreamFunction::compute_symgrad;

using ::MW::StreamFunction::compute_vvalue;

using ::MW::StreamFunction::compute_vjump;

using ::MW::StreamFunction::compute_average_symgrad;

using ::MW::StreamFunction::compute_average_grad;

using ::MW::StreamFunction::compute_vjump_tangential;



using ::MW::TestFunction::compute_grad;

using ::MW::TestFunction::compute_symgrad;

using ::MW::TestFunction::compute_vvalue;

using ::MW::TestFunction::compute_vvalue_tangential;



/**
 * Returns a pair of local face numbers and interface indices (the indexing
 * comes from @p interface_handler) for each interface cached in @p
 * interface_handler.
 */
template<int dim, typename CellIteratorType>
std::pair<std::vector<unsigned int>, std::vector<types::global_dof_index>>
make_active_interface_indices_impl(const InterfaceHandler<dim> & interface_handler,
                                   const CellIteratorType &      cell)
{
  std::pair<std::vector<unsigned int>, std::vector<types::global_dof_index>> indices;
  auto & [active_face_numbers, interface_indices] = indices;

  for(auto face_no = 0U; face_no < GeometryInfo<dim>::faces_per_cell; ++face_no)
  {
    const bool this_is_no_interface = cell->neighbor_index(face_no) == -1;
    if(this_is_no_interface)
      continue;

    const auto         ncell = cell->neighbor(face_no);
    InterfaceId        interface_id{cell->id(), ncell->id()};
    const unsigned int interface_index = interface_handler.get_interface_index(interface_id);

    const bool this_interface_isnt_contained = interface_index == numbers::invalid_unsigned_int;
    if(this_interface_isnt_contained)
      continue;

    active_face_numbers.push_back(face_no);
    interface_indices.push_back(interface_index);
  }

  AssertDimension(active_face_numbers.size(), interface_indices.size());
  return indices;
}



/**
 * From the global dof indices on the left and right cell and the mapping of
 * joint dof indices to local cell dof indices on the left and right cell,
 * respectively, the associated global interface dof indices are computed.
 */
std::vector<types::global_dof_index>
make_interface_dof_indices(const std::vector<std::array<unsigned int, 2>> & joint_to_cell_dof_map,
                           const std::vector<types::global_dof_index> & dof_indices_on_left_cell,
                           const std::vector<types::global_dof_index> & dof_indices_on_right_cell)
{
  AssertIndexRange(joint_to_cell_dof_map.size(),
                   dof_indices_on_left_cell.size() + dof_indices_on_right_cell.size() + 1);
  std::vector<types::global_dof_index> joint_dof_indices;
  for(auto j = 0U; j < joint_to_cell_dof_map.size(); ++j)
  {
    const auto [lj, rj] = joint_to_cell_dof_map[j];
    if(lj != numbers::invalid_unsigned_int)
      joint_dof_indices.emplace_back(dof_indices_on_left_cell[lj]);
    else if(rj != numbers::invalid_unsigned_int)
      joint_dof_indices.emplace_back(dof_indices_on_right_cell[rj]);
    else
      AssertThrow(false, ExcMessage("Check joint_to_cell_dof_map!"));
  }
  AssertDimension(joint_dof_indices.size(), joint_to_cell_dof_map.size());
  return joint_dof_indices;
}



/**
 * From the global dof indices and its associated test function indices on the
 * left and right cell, respectively, the mapping of local joint dof indices
 * to local pairs of cell dof indices on the left and right cell is computed.
 */
std::pair<std::vector<std::array<unsigned int, 2>>, std::vector<types::global_dof_index>>
make_joint_interface_indices(const std::vector<unsigned int> &            testfunc_indices_left,
                             const std::vector<types::global_dof_index> & dof_indices_on_lcell,
                             const std::vector<unsigned int> &            testfunc_indices_right,
                             const std::vector<types::global_dof_index> & dof_indices_on_rcell)
{
  AssertDimension(testfunc_indices_left.size(), dof_indices_on_lcell.size());
  AssertDimension(testfunc_indices_right.size(), dof_indices_on_rcell.size());

  std::vector<std::pair<unsigned int, types::global_dof_index>> testfunc_and_dof_indices_left;
  std::transform(testfunc_indices_left.cbegin(),
                 testfunc_indices_left.cend(),
                 dof_indices_on_lcell.cbegin(),
                 std::back_inserter(testfunc_and_dof_indices_left),
                 [](const auto i,
                    const auto dof) -> std::pair<unsigned int, types::global_dof_index> {
                   return {i, dof};
                 });
  std::vector<std::pair<unsigned int, types::global_dof_index>> testfunc_and_dof_indices_right;
  std::transform(testfunc_indices_right.cbegin(),
                 testfunc_indices_right.cend(),
                 dof_indices_on_rcell.cbegin(),
                 std::back_inserter(testfunc_and_dof_indices_right),
                 [](const auto i,
                    const auto dof) -> std::pair<unsigned int, types::global_dof_index> {
                   return {i, dof};
                 });

  std::pair<std::vector<std::array<unsigned int, 2>>, std::vector<types::global_dof_index>> indices;
  auto & [joint_testfunc_indices, interface_dof_indices] = indices;

  for(const auto [li, ldof] : testfunc_and_dof_indices_left)
  {
    interface_dof_indices.push_back(ldof);
    joint_testfunc_indices.push_back({li, numbers::invalid_unsigned_int});
  }

  for(const auto [ri, rdof] : testfunc_and_dof_indices_right)
  {
    const auto common_it =
      std::find_if(testfunc_and_dof_indices_left.cbegin(),
                   testfunc_and_dof_indices_left.cend(),
                   [&](const auto & li_and_ldof) { return li_and_ldof.second == rdof; });
    const bool is_common_dof = common_it != testfunc_and_dof_indices_left.cend();

    if(!is_common_dof)
    {
      interface_dof_indices.push_back(rdof);
      joint_testfunc_indices.push_back({numbers::invalid_unsigned_int, ri});
    }

    else
    {
      const auto [li, ldof] = *common_it;
      (void)ldof;
      auto joint_it = std::find_if(joint_testfunc_indices.begin(),
                                   joint_testfunc_indices.end(),
                                   [li](const auto li_and_ri) { return li_and_ri[0] == li; });
      Assert(joint_it != joint_testfunc_indices.end(), ExcMessage("..."));
      (*joint_it)[1] = ri;
    }
  }

  AssertDimension(joint_testfunc_indices.size(), interface_dof_indices.size());
  return indices;
}



template<int dim, bool is_multigrid = false, bool is_simplified = false>
struct MatrixIntegrator
{
  using IteratorType = typename ::MW::IteratorSelector<dim, is_multigrid>::type;

  MatrixIntegrator(const Function<dim> *                              load_function_in,
                   const Function<dim> *                              analytical_solution_in,
                   const LinearAlgebra::distributed::Vector<double> * particular_solution,
                   const EquationData &                               equation_data_in,
                   const InterfaceHandler<dim> * interface_handler_in = nullptr)
    : load_function(load_function_in),
      analytical_solution(analytical_solution_in),
      discrete_solution(particular_solution),
      equation_data(equation_data_in),
      interface_handler(interface_handler_in)
  {
  }

  void
  cell_worker(const IteratorType & cell,
              ScratchData<dim> &   scratch_data,
              CopyData &           copy_data) const;

  void
  cell_worker_stream(const IteratorType & cell,
                     ScratchData<dim> &   scratch_data,
                     CopyData &           copy_data) const;

  void
  cell_residual_worker(const IteratorType &     cell_velocity,
                       const IteratorType &     cell_stream,
                       const IteratorType &     cell_pressure,
                       ScratchData<dim, true> & scratch_data,
                       CopyData &               copy_data) const;

  void
  cell_residual_worker_interface(const IteratorType &     cell_velocity,
                                 const IteratorType &     cell_stream,
                                 ScratchData<dim, true> & scratch_data,
                                 CopyData &               copy_data) const;

  template<typename TestEvaluatorType, typename AnsatzEvaluatorType>
  void
  cell_worker_impl(const TestEvaluatorType &   phi_test,
                   const AnsatzEvaluatorType & phi_ansatz,
                   CopyData::CellData &        copy_data) const;

  void
  face_worker(const IteratorType & cell,
              const unsigned int & f,
              const unsigned int & sf,
              const IteratorType & ncell,
              const unsigned int & nf,
              const unsigned int & nsf,
              ScratchData<dim> &   scratch_data,
              CopyData &           copy_data) const;

  void
  face_worker_stream(const IteratorType & cell,
                     const unsigned int & f,
                     const unsigned int & sf,
                     const IteratorType & ncell,
                     const unsigned int & nf,
                     const unsigned int & nsf,
                     ScratchData<dim> &   scratch_data,
                     CopyData &           copy_data) const;

  void
  face_worker_tangential(const IteratorType & cell,
                         const unsigned int & f,
                         const unsigned int & sf,
                         const IteratorType & ncell,
                         const unsigned int & nf,
                         const unsigned int & nsf,
                         ScratchData<dim> &   scratch_data,
                         CopyData &           copy_data) const;

  void
  face_worker_tangential_stream(const IteratorType & cell,
                                const unsigned int & f,
                                const unsigned int & sf,
                                const IteratorType & ncell,
                                const unsigned int & nf,
                                const unsigned int & nsf,
                                ScratchData<dim> &   scratch_data,
                                CopyData &           copy_data) const;

  void
  face_residual_worker_tangential(const IteratorType &     cell,
                                  const IteratorType &     cell_stream,
                                  const IteratorType &     cell_pressure,
                                  const unsigned int &     f,
                                  const unsigned int &     sf,
                                  const IteratorType &     ncell,
                                  const IteratorType &     ncell_stream,
                                  const IteratorType &     ncell_pressure,
                                  const unsigned int &     nf,
                                  const unsigned int &     nsf,
                                  ScratchData<dim, true> & scratch_data,
                                  CopyData &               copy_data) const;

  void
  face_residual_worker_tangential_interface(const IteratorType &     cell,
                                            const IteratorType &     cell_stream,
                                            const unsigned int &     f,
                                            const unsigned int &     sf,
                                            const IteratorType &     ncell,
                                            const IteratorType &     ncell_stream,
                                            const unsigned int &     nf,
                                            const unsigned int &     nsf,
                                            ScratchData<dim, true> & scratch_data,
                                            CopyData &               copy_data) const;

  template<typename TestEvaluatorType, typename AnsatzEvaluatorType>
  void
  face_worker_impl(const TestEvaluatorType &   phi_test,
                   const AnsatzEvaluatorType & phi_ansatz,
                   const double                gamma_over_h,
                   CopyData::FaceData &        copy_data) const;

  template<typename TestEvaluatorType, typename AnsatzEvaluatorType>
  void
  face_worker_tangential_impl(const TestEvaluatorType &   phi_test,
                              const AnsatzEvaluatorType & phi_ansatz,
                              const double                gamma_over_h,
                              CopyData::FaceData &        copy_data) const;

  template<bool is_uniface>
  void
  boundary_or_uniface_residual_worker_tangential(const IteratorType &     cell,
                                                 const IteratorType &     cell_stream,
                                                 const IteratorType &     cell_pressure,
                                                 const unsigned int &     face_no,
                                                 const unsigned int &     sface_no,
                                                 ScratchData<dim, true> & scratch_data,
                                                 CopyData &               copy_data) const;

  template<bool is_uniface>
  void
  boundary_or_uniface_residual_worker_tangential_interface(const IteratorType &     cell,
                                                           const IteratorType &     cell_stream,
                                                           const unsigned int &     face_no,
                                                           const unsigned int &     sface_no,
                                                           ScratchData<dim, true> & scratch_data,
                                                           CopyData & copy_data) const;

  template<bool is_uniface, typename TestEvaluatorType, typename AnsatzEvaluatorType>
  void
  boundary_or_uniface_worker_impl(const TestEvaluatorType &   phi_test,
                                  const AnsatzEvaluatorType & phi_ansatz,
                                  const double                gamma_over_h,
                                  CopyData::FaceData &        face_data) const;

  template<bool is_uniface, typename TestEvaluatorType, typename AnsatzEvaluatorType>
  void
  boundary_or_uniface_worker_tangential_impl(const TestEvaluatorType &   phi_test,
                                             const AnsatzEvaluatorType & phi_ansatz,
                                             const double                gamma_over_h,
                                             CopyData::FaceData &        face_data) const;

  void
  uniface_worker(const IteratorType & cell,
                 const unsigned int & f,
                 const unsigned int & sf,
                 ScratchData<dim> &   scratch_data,
                 CopyData &           copy_data) const;

  void
  uniface_worker_stream(const IteratorType & cell,
                        const unsigned int & f,
                        const unsigned int & sf,
                        ScratchData<dim> &   scratch_data,
                        CopyData &           copy_data) const;

  void
  uniface_worker_tangential(const IteratorType & cell,
                            const unsigned int & f,
                            const unsigned int & sf,
                            ScratchData<dim> &   scratch_data,
                            CopyData &           copy_data) const;

  void
  uniface_worker_tangential_stream(const IteratorType & cell,
                                   const unsigned int & f,
                                   const unsigned int & sf,
                                   ScratchData<dim> &   scratch_data,
                                   CopyData &           copy_data) const;

  void
  uniface_residual_worker_tangential(const IteratorType &     cell,
                                     const IteratorType &     cell_stream,
                                     const IteratorType &     cell_pressure,
                                     const unsigned int &     face_no,
                                     const unsigned int &     sface_no,
                                     ScratchData<dim, true> & scratch_data,
                                     CopyData &               copy_data) const;

  void
  uniface_residual_worker_tangential_interface(const IteratorType &     cell,
                                               const IteratorType &     cell_stream,
                                               const unsigned int &     face_no,
                                               const unsigned int &     sface_no,
                                               ScratchData<dim, true> & scratch_data,
                                               CopyData &               copy_data) const;

  /// TODO remove if completely obsolete !!!
  template<typename TestEvaluatorType, typename AnsatzEvaluatorType>
  void
  uniface_worker_impl(const TestEvaluatorType &   phi_test,
                      const AnsatzEvaluatorType & phi_ansatz,
                      const double                gamma_over_h,
                      CopyData::FaceData &        face_data) const;

  void
  boundary_worker(const IteratorType & cell,
                  const unsigned int & face_no,
                  ScratchData<dim> &   scratch_data,
                  CopyData &           copy_data) const;

  void
  boundary_worker_stream(const IteratorType & cell,
                         const unsigned int & face_no,
                         ScratchData<dim> &   scratch_data,
                         CopyData &           copy_data) const;

  void
  boundary_worker_tangential(const IteratorType & cell,
                             const unsigned int & face_no,
                             ScratchData<dim> &   scratch_data,
                             CopyData &           copy_data) const;

  void
  boundary_worker_tangential_stream(const IteratorType & cell,
                                    const unsigned int & face_no,
                                    ScratchData<dim> &   scratch_data,
                                    CopyData &           copy_data) const;

  void
  boundary_residual_worker_tangential(const IteratorType &     cell,
                                      const IteratorType &     cell_stream,
                                      const IteratorType &     cell_pressure,
                                      const unsigned int &     face_no,
                                      ScratchData<dim, true> & scratch_data,
                                      CopyData &               copy_data) const;

  void
  boundary_residual_worker_tangential_interface(const IteratorType &     cell,
                                                const IteratorType &     cell_stream,
                                                const unsigned int &     face_no,
                                                ScratchData<dim, true> & scratch_data,
                                                CopyData &               copy_data) const;

  /// TODO remove if completely obsolete !!!
  // template<bool do_rhs, typename TestEvaluatorType, typename AnsatzEvaluatorType>
  // void
  // boundary_worker_impl(const TestEvaluatorType &   phi_test,
  //                      const AnsatzEvaluatorType & phi_ansatz,
  //                      const double                gamma_over_h,
  //                      CopyData::FaceData &        copy_data) const;

  /// TODO remove if completely obsolete !!!
  // template<bool do_rhs, typename TestEvaluatorType, typename AnsatzEvaluatorType>
  // void
  // boundary_worker_tangential_impl(const TestEvaluatorType &   phi_test,
  //                                 const AnsatzEvaluatorType & phi_ansatz,
  //                                 const double                gamma_over_h,
  //                                 CopyData::FaceData &        copy_data) const;

  /**
   * We query the underlying InterfaceHandler to return the local-global pair of
   * interface indices associated to the current cell @p cell.
   */
  std::pair<std::vector<unsigned int>, std::vector<types::global_dof_index>>
  get_active_interface_indices(const IteratorType & cell) const;

  const Function<dim> *                              load_function;
  const Function<dim> *                              analytical_solution;
  const LinearAlgebra::distributed::Vector<double> * discrete_solution;
  const EquationData                                 equation_data;
  const InterfaceHandler<dim> *                      interface_handler;
};



template<int dim, bool is_multigrid, bool is_simplified>
void
MatrixIntegrator<dim, is_multigrid, is_simplified>::cell_worker(const IteratorType & cell,
                                                                ScratchData<dim> &   scratch_data,
                                                                CopyData & copy_data) const
{
  AssertDimension(copy_data.cell_data.size(), 0U);

  FEValues<dim> & phi = scratch_data.fe_values_test;
  phi.reinit(cell);

  const unsigned int n_dofs_per_cell = phi.get_fe().dofs_per_cell;

  auto & cell_data = copy_data.cell_data.emplace_back(n_dofs_per_cell);

  cell->get_active_or_mg_dof_indices(cell_data.dof_indices);

  cell_worker_impl(phi, phi, cell_data);

  /// Subtract the particular solution @p discrete_solution from the right hand
  /// side, thus, as usual moving essential boundary conditions to the right
  /// hand side.
  ///
  /// If @p discrete_solution is not set (for example for a DG method) we skip
  /// here.
  if(!is_multigrid)
    if(discrete_solution && cell->at_boundary())
    {
      Vector<double> u0(cell_data.dof_indices.size());
      for(auto i = 0U; i < u0.size(); ++i)
        u0(i) = (*discrete_solution)(cell_data.dof_indices[i]);
      Vector<double> w0(cell_data.dof_indices.size());
      cell_data.matrix.vmult(w0, u0);
      cell_data.rhs -= w0;
    }
}



template<int dim, bool is_multigrid, bool is_simplified>
void
MatrixIntegrator<dim, is_multigrid, is_simplified>::cell_worker_stream(
  const IteratorType & cell,
  ScratchData<dim> &   scratch_data,
  CopyData &           copy_data) const
{
  AssertDimension(copy_data.cell_data.size(), 0U);

  auto & phi = scratch_data.stream_values;
  phi.reinit(cell);

  auto & cell_data = copy_data.cell_data.emplace_back(phi.n_dofs_per_cell());

  cell->get_active_or_mg_dof_indices(cell_data.dof_indices);

  cell_worker_impl(phi, phi, cell_data);

  /// Subtract the particular solution @p discrete_solution from the right hand
  /// side, thus, as usual moving essential boundary conditions to the right
  /// hand side.
  ///
  /// If @p discrete_solution is not set (for example for a DG method) we skip
  /// here.
  if(!is_multigrid)
    if(discrete_solution && cell->at_boundary())
    {
      Vector<double> u0(cell_data.dof_indices.size());
      for(auto i = 0U; i < u0.size(); ++i)
        u0(i) = (*discrete_solution)(cell_data.dof_indices[i]);
      Vector<double> w0(cell_data.dof_indices.size());
      cell_data.matrix.vmult(w0, u0);
      cell_data.rhs -= w0;
    }
}



template<int dim, bool is_multigrid, bool is_simplified>
void
MatrixIntegrator<dim, is_multigrid, is_simplified>::cell_residual_worker(
  const IteratorType &     cell,
  const IteratorType &     cell_stream,
  const IteratorType &     cell_pressure,
  ScratchData<dim, true> & scratch_data,
  CopyData &               copy_data) const
{
  AssertDimension(copy_data.cell_data.size(), 0U);

  auto & phi_test = scratch_data.test_values;
  phi_test.reinit(cell);

  auto & phi_ansatz = scratch_data.stream_values_ansatz;
  phi_ansatz.reinit(cell_stream);

  auto & cell_data =
    copy_data.cell_data.emplace_back(phi_test.n_dofs_per_cell(), phi_ansatz.n_dofs_per_cell());

  AssertDimension(phi_test.n_dofs_per_cell(), cell_data.dof_indices.size());

  std::vector<types::global_dof_index> dof_indices_pressure(cell_data.dof_indices.size() + 1);
  cell_pressure->get_active_or_mg_dof_indices(dof_indices_pressure);
  AssertDimension(dof_indices_pressure.size(), cell_data.dof_indices.size() + 1);
  std::copy(dof_indices_pressure.cbegin() + 1,
            dof_indices_pressure.cend(),
            cell_data.dof_indices.begin());

  cell_stream->get_active_or_mg_dof_indices(cell_data.dof_indices_column);

  cell_worker_impl(phi_test, phi_ansatz, cell_data);

  if(discrete_solution)
  {
    Vector<double> dof_values(cell_data.dof_indices_column.size());
    std::transform(cell_data.dof_indices_column.cbegin(),
                   cell_data.dof_indices_column.cend(),
                   dof_values.begin(),
                   [&](const auto dof_index) { return (*discrete_solution)[dof_index]; });

    /// computing the residual
    Vector<double> Ax(cell_data.rhs.size());
    cell_data.matrix.vmult(Ax, dof_values); // Ax
    cell_data.rhs -= Ax;                    // f - Ax

    cell_data.dof_indices_column.resize(2U);
    /// book-keeping the index of the first pressure dof
    cell_data.dof_indices_column.front() = dof_indices_pressure.front();
    /// book-keeping the custom cell index
    cell_data.dof_indices_column.back() = interface_handler->get_cell_index(cell->id());
  }
}



template<int dim, bool is_multigrid, bool is_simplified>
void
MatrixIntegrator<dim, is_multigrid, is_simplified>::cell_residual_worker_interface(
  const IteratorType &     cell,
  const IteratorType &     cell_stream,
  ScratchData<dim, true> & scratch_data,
  CopyData &               copy_data) const
{
  AssertDimension(copy_data.cell_data.size(), 0U);

  /// We determine for which "outflow" interfaces this cell is the source cell:
  /// local face numbers and global interface indices are returned.
  auto [active_test_function_indices, global_interface_indices] =
    get_active_interface_indices(cell);

  auto & phi_test = scratch_data.test_values;
  /// Restricting TestFunction::Values to those test functions which are active
  /// on associated "outflow" interfaces for this cell.
  phi_test.reinit(cell, active_test_function_indices);

  AssertDimension(phi_test.shape_to_test_functions.m(), GeometryInfo<dim>::faces_per_cell);

  auto & phi_ansatz = scratch_data.stream_values_ansatz;
  phi_ansatz.reinit(cell_stream);

  auto & cell_data =
    copy_data.cell_data.emplace_back(phi_test.n_dofs_per_cell(), phi_ansatz.n_dofs_per_cell());

  cell_data.dof_indices = std::move(global_interface_indices);

  cell_stream->get_active_or_mg_dof_indices(cell_data.dof_indices_column);

  cell_worker_impl(phi_test, phi_ansatz, cell_data);

  AssertDimension(cell_data.matrix.n(), cell_data.dof_indices_column.size());

  if(discrete_solution)
  {
    Vector<double> dof_values(cell_data.dof_indices_column.size());
    std::transform(cell_data.dof_indices_column.cbegin(),
                   cell_data.dof_indices_column.cend(),
                   dof_values.begin(),
                   [&](const auto dof_index) { return (*discrete_solution)[dof_index]; });

    AssertDimension(cell_data.matrix.m(), cell_data.rhs.size());
    Vector<double> Ax(cell_data.rhs.size());
    cell_data.matrix.vmult(Ax, dof_values); // Ax
    cell_data.rhs -= Ax;                    // f - Ax
  }
}



template<int dim, bool is_multigrid, bool is_simplified>
template<typename TestEvaluatorType, typename AnsatzEvaluatorType>
void
MatrixIntegrator<dim, is_multigrid, is_simplified>::cell_worker_impl(
  const TestEvaluatorType &   phi_test,
  const AnsatzEvaluatorType & phi_ansatz,
  CopyData::CellData &        cell_data) const
{
  std::vector<Tensor<1, dim>> load_values;
  if(!is_multigrid)
  {
    AssertDimension(cell_data.matrix.m(), cell_data.rhs.size());
    Assert(load_function, ExcMessage("load_function is not set."));
    AssertDimension(load_function->n_components, dim);
    const auto & q_points = phi_test.get_quadrature_points();
    std::transform(q_points.cbegin(),
                   q_points.cend(),
                   std::back_inserter(load_values),
                   [this](const auto & x_q) {
                     Tensor<1, dim> value;
                     for(auto c = 0U; c < dim; ++c)
                       value[c] = load_function->value(x_q, c);
                     return value;
                   });
  }

  for(unsigned int q = 0; q < phi_test.n_quadrature_points; ++q)
  {
    const auto & dx = phi_test.JxW(q);
    for(unsigned int i = 0; i < cell_data.matrix.m(); ++i)
    {
      if(!is_simplified)
      {
        const SymmetricTensor<2, dim> symgrad_phi_i = compute_symgrad(phi_test, i, q);
        for(unsigned int j = 0; j < cell_data.matrix.n(); ++j)
        {
          const SymmetricTensor<2, dim> symgrad_phi_j = compute_symgrad(phi_ansatz, j, q);
          cell_data.matrix(i, j) += 2. *
                                    scalar_product(symgrad_phi_i,   // symgrad phi_i(x)
                                                   symgrad_phi_j) * // symgrad phi_j(x)
                                    dx;                             // dx
        }
      }
      else
      {
        const Tensor<2, dim> grad_phi_i = compute_grad(phi_test, i, q);
        for(unsigned int j = 0; j < cell_data.matrix.n(); ++j)
        {
          const Tensor<2, dim> grad_phi_j = compute_grad(phi_ansatz, j, q);
          cell_data.matrix(i, j) += scalar_product(grad_phi_i,   // grad phi_i(x)
                                                   grad_phi_j) * // grad phi_j(x)
                                    dx;                          // dx
        }
      }

      if(!is_multigrid)
      {
        const auto & f     = load_values[q];
        const auto & phi_i = compute_vvalue(phi_test, i, q);
        cell_data.rhs(i) += f * phi_i * dx;
      }
    }
  }
}



template<int dim, bool is_multigrid, bool is_simplified>
void
MatrixIntegrator<dim, is_multigrid, is_simplified>::face_worker(const IteratorType & cell,
                                                                const unsigned int & f,
                                                                const unsigned int & sf,
                                                                const IteratorType & ncell,
                                                                const unsigned int & nf,
                                                                const unsigned int & nsf,
                                                                ScratchData<dim> &   scratch_data,
                                                                CopyData & copy_data) const
{
  FEInterfaceValues<dim> & fe_interface_values = scratch_data.fe_interface_values_test;
  fe_interface_values.reinit(cell, f, sf, ncell, nf, nsf);

  const unsigned int n_interface_dofs = fe_interface_values.n_current_interface_dofs();

  CopyData::FaceData & face_data = copy_data.face_data.emplace_back(n_interface_dofs);

  face_data.dof_indices        = fe_interface_values.get_interface_dof_indices();
  face_data.dof_indices_column = fe_interface_values.get_interface_dof_indices();

  const auto   h         = cell->extent_in_direction(GeometryInfo<dim>::unit_normal_direction[f]);
  const auto   nh        = ncell->extent_in_direction(GeometryInfo<dim>::unit_normal_direction[nf]);
  const auto   fe_degree = scratch_data.fe_values_test.get_fe().degree;
  const double gamma_over_h =
    equation_data.ip_factor * 0.5 * compute_penalty_impl(fe_degree, h, nh);

  face_worker_impl(fe_interface_values, fe_interface_values, gamma_over_h, face_data);

  AssertDimension(face_data.matrix.m(), n_interface_dofs);
  AssertDimension(face_data.matrix.n(), n_interface_dofs);
}



template<int dim, bool is_multigrid, bool is_simplified>
void
MatrixIntegrator<dim, is_multigrid, is_simplified>::face_worker_stream(
  const IteratorType & cell,
  const unsigned int & face_no,
  const unsigned int & sface_no,
  const IteratorType & ncell,
  const unsigned int & nface_no,
  const unsigned int & nsface_no,
  ScratchData<dim> &   scratch_data,
  CopyData &           copy_data) const
{
  auto & phi = scratch_data.stream_interface_values;
  phi.reinit(cell, face_no, sface_no, ncell, nface_no, nsface_no);

  const unsigned int   n_interface_dofs = phi.n_current_interface_dofs();
  CopyData::FaceData & face_data        = copy_data.face_data.emplace_back(n_interface_dofs);

  face_data.dof_indices = phi.get_interface_dof_indices();

  const auto   h  = cell->extent_in_direction(GeometryInfo<dim>::unit_normal_direction[face_no]);
  const auto   nh = ncell->extent_in_direction(GeometryInfo<dim>::unit_normal_direction[nface_no]);
  const auto   fe_degree = scratch_data.fe_values_test.get_fe().degree;
  const double gamma_over_h =
    equation_data.ip_factor * 0.5 * compute_penalty_impl(fe_degree, h, nh);

  face_worker_impl(phi, phi, gamma_over_h, face_data);

  AssertDimension(face_data.matrix.m(), n_interface_dofs);
  AssertDimension(face_data.matrix.n(), n_interface_dofs);
}



template<int dim, bool is_multigrid, bool is_simplified>
void
MatrixIntegrator<dim, is_multigrid, is_simplified>::face_worker_tangential_stream(
  const IteratorType & cell,
  const unsigned int & face_no,
  const unsigned int & sface_no,
  const IteratorType & ncell,
  const unsigned int & nface_no,
  const unsigned int & nsface_no,
  ScratchData<dim> &   scratch_data,
  CopyData &           copy_data) const
{
  auto & phi = scratch_data.stream_interface_values;
  phi.reinit(cell, face_no, sface_no, ncell, nface_no, nsface_no);

  const unsigned int   n_interface_dofs = phi.n_current_interface_dofs();
  CopyData::FaceData & face_data        = copy_data.face_data.emplace_back(n_interface_dofs);

  face_data.dof_indices = phi.get_interface_dof_indices();

  const auto   h  = cell->extent_in_direction(GeometryInfo<dim>::unit_normal_direction[face_no]);
  const auto   nh = ncell->extent_in_direction(GeometryInfo<dim>::unit_normal_direction[nface_no]);
  const auto   fe_degree = scratch_data.fe_values_test.get_fe().degree;
  const double gamma_over_h =
    equation_data.ip_factor * 0.5 * compute_penalty_impl(fe_degree, h, nh);

  face_worker_tangential_impl(phi, phi, gamma_over_h, face_data);

  AssertDimension(face_data.matrix.m(), n_interface_dofs);
  AssertDimension(face_data.matrix.n(), n_interface_dofs);
}



template<int dim, bool is_multigrid, bool is_simplified>
template<typename TestEvaluatorType, typename AnsatzEvaluatorType>
void
MatrixIntegrator<dim, is_multigrid, is_simplified>::face_worker_impl(
  const TestEvaluatorType &   phi_test,
  const AnsatzEvaluatorType & phi_ansatz,
  const double                gamma_over_h,
  CopyData::FaceData &        face_data) const
{
  const auto n_interface_dofs_test   = phi_test.n_current_interface_dofs();
  const auto n_interface_dofs_ansatz = phi_ansatz.n_current_interface_dofs();

  AssertDimension(face_data.matrix.m(), n_interface_dofs_test);
  AssertDimension(face_data.matrix.n(), n_interface_dofs_ansatz);

  double integral_ijq = 0.;
  for(unsigned int q = 0; q < phi_test.n_quadrature_points; ++q)
  {
    const auto & n  = phi_test.normal(q);
    const auto & dx = phi_test.JxW(q);
    for(unsigned int i = 0; i < n_interface_dofs_test; ++i)
    {
      if(!is_simplified)
      {
        const auto & av_symgrad_phi_i   = compute_average_symgrad(phi_test, i, q);
        const auto & jump_phi_i         = compute_vjump(phi_test, i, q);
        const auto & jump_phi_i_cross_n = outer_product(jump_phi_i, n);

        for(unsigned int j = 0; j < n_interface_dofs_ansatz; ++j)
        {
          const auto & av_symgrad_phi_j   = compute_average_symgrad(phi_ansatz, j, q);
          const auto & jump_phi_j         = compute_vjump(phi_ansatz, j, q);
          const auto & jump_phi_j_cross_n = outer_product(jump_phi_j, n);

          integral_ijq = -scalar_product(av_symgrad_phi_j, jump_phi_i_cross_n);
          integral_ijq += -scalar_product(jump_phi_j_cross_n, av_symgrad_phi_i);
          integral_ijq += gamma_over_h * jump_phi_j * jump_phi_i;
          integral_ijq *= 2. * dx;

          face_data.matrix(i, j) += integral_ijq;
        }
      }
      else
      {
        const auto & av_grad_phi_i      = compute_average_grad(phi_test, i, q);
        const auto & jump_phi_i         = compute_vjump(phi_test, i, q);
        const auto & jump_n_cross_phi_i = outer_product(n, jump_phi_i);

        for(unsigned int j = 0; j < n_interface_dofs_ansatz; ++j)
        {
          const auto & av_grad_phi_j      = compute_average_grad(phi_ansatz, j, q);
          const auto & jump_phi_j         = compute_vjump(phi_ansatz, j, q);
          const auto & jump_n_cross_phi_j = outer_product(n, jump_phi_j);

          integral_ijq = -scalar_product(av_grad_phi_j, jump_n_cross_phi_i);
          integral_ijq += -scalar_product(jump_n_cross_phi_j, av_grad_phi_i);
          integral_ijq += gamma_over_h * jump_phi_j * jump_phi_i;
          integral_ijq *= dx;

          face_data.matrix(i, j) += integral_ijq;
        }
      }
    }
  }
}



template<int dim, bool is_multigrid, bool is_simplified>
void
MatrixIntegrator<dim, is_multigrid, is_simplified>::face_worker_tangential(
  const IteratorType & cell,
  const unsigned int & face_no,
  const unsigned int & sface_no,
  const IteratorType & ncell,
  const unsigned int & nface_no,
  const unsigned int & nsface_no,
  ScratchData<dim> &   scratch_data,
  CopyData &           copy_data) const
{
  FEInterfaceValues<dim> & phi = scratch_data.fe_interface_values_test;
  phi.reinit(cell, face_no, sface_no, ncell, nface_no, nsface_no);

  const unsigned int n_interface_dofs = phi.n_current_interface_dofs();

  CopyData::FaceData & face_data = copy_data.face_data.emplace_back(n_interface_dofs);

  face_data.dof_indices = phi.get_interface_dof_indices();

  const auto   h  = cell->extent_in_direction(GeometryInfo<dim>::unit_normal_direction[face_no]);
  const auto   nh = ncell->extent_in_direction(GeometryInfo<dim>::unit_normal_direction[nface_no]);
  const auto   fe_degree = scratch_data.fe_values_test.get_fe().degree;
  const double gamma_over_h =
    equation_data.ip_factor * 0.5 * compute_penalty_impl(fe_degree, h, nh);

  face_worker_tangential_impl(phi, phi, gamma_over_h, face_data);
}



template<int dim, bool is_multigrid, bool is_simplified>
template<typename TestEvaluatorType, typename AnsatzEvaluatorType>
void
MatrixIntegrator<dim, is_multigrid, is_simplified>::face_worker_tangential_impl(
  const TestEvaluatorType &   phi_test,
  const AnsatzEvaluatorType & phi_ansatz,
  const double                gamma_over_h,
  CopyData::FaceData &        face_data) const
{
  const auto n_interface_dofs_test   = phi_test.n_current_interface_dofs();
  const auto n_interface_dofs_ansatz = phi_ansatz.n_current_interface_dofs();

  AssertDimension(face_data.matrix.m(), n_interface_dofs_test);
  AssertDimension(face_data.matrix.n(), n_interface_dofs_ansatz);

  const std::vector<Tensor<1, dim>> & normals = phi_test.get_normal_vectors();

  double integral_ijq = 0.;
  for(unsigned int q = 0; q < phi_test.n_quadrature_points; ++q)
  {
    const auto & n = normals[q];
    for(unsigned int i = 0; i < n_interface_dofs_test; ++i)
    {
      if(!is_simplified)
      {
        const auto & av_symgrad_phi_i = compute_average_symgrad(phi_test, i, q);
        const auto & jump_phit_i      = compute_vjump_tangential(phi_test, i, q);
        double       ncontrib_i       = n * av_symgrad_phi_i * n;

        for(unsigned int j = 0; j < n_interface_dofs_ansatz; ++j)
        {
          const auto & av_symgrad_phi_j = compute_average_symgrad(phi_ansatz, j, q);
          const auto & jump_phit_j      = compute_vjump_tangential(phi_ansatz, j, q);
          double       ncontrib_j       = n * av_symgrad_phi_j * n;

          integral_ijq = -(n * av_symgrad_phi_j - ncontrib_j * n) * jump_phit_i;
          integral_ijq += -(n * av_symgrad_phi_i - ncontrib_i * n) * jump_phit_j;
          integral_ijq += gamma_over_h * jump_phit_j * jump_phit_i;
          integral_ijq *= 2. * phi_test.JxW(q);

          face_data.matrix(i, j) += integral_ijq;
        }
      }
      else
      {
        const auto & av_grad_phi_i = compute_average_grad(phi_test, i, q);
        const auto & jump_phit_i   = compute_vjump_tangential(phi_test, i, q);
        double       ncontrib_i    = n * av_grad_phi_i * n;

        for(unsigned int j = 0; j < n_interface_dofs_ansatz; ++j)
        {
          const auto & av_grad_phi_j = compute_average_grad(phi_ansatz, j, q);
          const auto & jump_phit_j   = compute_vjump_tangential(phi_ansatz, j, q);
          double       ncontrib_j    = n * av_grad_phi_j * n;

          integral_ijq = -(n * av_grad_phi_j - ncontrib_j * n) * jump_phit_i;
          integral_ijq += -(n * av_grad_phi_i - ncontrib_i * n) * jump_phit_j;
          integral_ijq += gamma_over_h * jump_phit_j * jump_phit_i;
          integral_ijq *= phi_test.JxW(q);

          face_data.matrix(i, j) += integral_ijq;
        }
      }
    }
  }
}



template<int dim, bool is_multigrid, bool is_simplified>
void
MatrixIntegrator<dim, is_multigrid, is_simplified>::face_residual_worker_tangential(
  const IteratorType &     cell,
  const IteratorType &     cell_stream,
  const IteratorType &     cell_pressure,
  const unsigned int &     face_no,
  const unsigned int &     subface_no,
  const IteratorType &     ncell,
  const IteratorType &     ncell_stream,
  const IteratorType &     ncell_pressure,
  const unsigned int &     nface_no,
  const unsigned int &     nsubface_no,
  ScratchData<dim, true> & scratch_data,
  CopyData &               copy_data) const
{
  auto & phi_test = scratch_data.test_interface_values;
  phi_test.reinit(cell, face_no, subface_no, ncell, nface_no, nsubface_no);

  auto & phi_ansatz = scratch_data.stream_interface_values_ansatz;
  phi_ansatz.reinit(cell_stream, face_no, subface_no, ncell_stream, nface_no, nsubface_no);

  CopyData::FaceData & face_data =
    copy_data.face_data.emplace_back(phi_test.n_current_interface_dofs(),
                                     phi_ansatz.n_current_interface_dofs());

  /// Test functions are 1-to-1 with pressure dofs (except constant mode)!
  const auto & make_dof_indices_skipping_first = [](const auto & cell) {
    std::vector<types::global_dof_index> all(cell->get_fe().dofs_per_cell);
    cell->get_active_or_mg_dof_indices(all);
    return std::vector<types::global_dof_index>(all.begin() + 1, all.end());
  };
  const auto dof_indices_on_lcell_pressure =
    std::move(make_dof_indices_skipping_first(cell_pressure));
  const auto dof_indices_on_rcell_pressure =
    std::move(make_dof_indices_skipping_first(ncell_pressure));
  face_data.dof_indices =
    std::move(make_interface_dof_indices(phi_test.get_interface_test_function_indices(),
                                         dof_indices_on_lcell_pressure,
                                         dof_indices_on_rcell_pressure));

  face_data.dof_indices_column = std::move(phi_ansatz.get_interface_dof_indices());

  AssertDimension(face_data.matrix.m(), face_data.dof_indices.size());
  AssertDimension(face_data.matrix.n(), face_data.dof_indices_column.size());

  const auto   h  = cell->extent_in_direction(GeometryInfo<dim>::unit_normal_direction[face_no]);
  const auto   nh = ncell->extent_in_direction(GeometryInfo<dim>::unit_normal_direction[nface_no]);
  const auto   fe_degree = phi_ansatz.get_fe().degree; // stream function degree !
  const double gamma_over_h =
    equation_data.ip_factor * 0.5 * compute_penalty_impl(fe_degree, h, nh);

  face_worker_tangential_impl(phi_test, phi_ansatz, gamma_over_h, face_data);

  if(discrete_solution)
  {
    Vector<double> dof_values(face_data.dof_indices_column.size());
    std::transform(face_data.dof_indices_column.cbegin(),
                   face_data.dof_indices_column.cend(),
                   dof_values.begin(),
                   [&](const auto dof_index) { return (*discrete_solution)[dof_index]; });

    AssertDimension(face_data.matrix.n(), dof_values.size());
    AssertDimension(face_data.matrix.m(), face_data.rhs.size());
    Vector<double> Ax(face_data.rhs.size());
    face_data.matrix.vmult(Ax, dof_values); // Ax
    face_data.rhs -= Ax;                    // f - Ax
  }
}



template<int dim, bool is_multigrid, bool is_simplified>
void
MatrixIntegrator<dim, is_multigrid, is_simplified>::face_residual_worker_tangential_interface(
  const IteratorType &     cell,
  const IteratorType &     cell_stream,
  const unsigned int &     face_no,
  const unsigned int &     sface_no,
  const IteratorType &     ncell,
  const IteratorType &     ncell_stream,
  const unsigned int &     nface_no,
  const unsigned int &     nsface_no,
  ScratchData<dim, true> & scratch_data,
  CopyData &               copy_data) const
{
  // const InterfaceId interface_id{cell->id(), ncell->id()};
  // const auto        interface_index        =
  // interface_handler->get_interface_index(interface_id); const bool this_interface_isnt_contained
  // = interface_index == numbers::invalid_unsigned_int;
  // if(this_interface_isnt_contained)
  //   return;

  const auto & [active_test_function_indices_left, global_interface_indices_left] =
    get_active_interface_indices(cell);
  const auto & [active_test_function_indices_right, global_interface_indices_right] =
    get_active_interface_indices(ncell);

  /// Determines the joint test function indices required by InterfaceValues and
  /// caches the global interface indices.
  auto [active_joint_indices, global_interface_indices] =
    make_joint_interface_indices(active_test_function_indices_left,
                                 global_interface_indices_left,
                                 active_test_function_indices_right,
                                 global_interface_indices_right);

  auto & phi_test = scratch_data.test_interface_values;
  phi_test.reinit(cell, face_no, sface_no, ncell, nface_no, nsface_no, active_joint_indices);

  AssertDimension(phi_test.shape_to_test_functions_left.m(), GeometryInfo<dim>::faces_per_cell);
  AssertDimension(phi_test.shape_to_test_functions_right.m(), GeometryInfo<dim>::faces_per_cell);

  auto & phi_ansatz = scratch_data.stream_interface_values_ansatz;
  phi_ansatz.reinit(cell_stream, face_no, sface_no, ncell_stream, nface_no, nsface_no);

  CopyData::FaceData & face_data =
    copy_data.face_data.emplace_back(phi_test.n_current_interface_dofs(),
                                     phi_ansatz.n_current_interface_dofs());

  face_data.dof_indices = std::move(global_interface_indices);

  face_data.dof_indices_column = phi_ansatz.get_interface_dof_indices();

  const auto   h  = cell->extent_in_direction(GeometryInfo<dim>::unit_normal_direction[face_no]);
  const auto   nh = ncell->extent_in_direction(GeometryInfo<dim>::unit_normal_direction[nface_no]);
  const auto   fe_degree = phi_ansatz.get_fe().degree; // stream function ansatz !
  const double gamma_over_h =
    equation_data.ip_factor * 0.5 * compute_penalty_impl(fe_degree, h, nh);

  face_worker_tangential_impl(phi_test, phi_ansatz, gamma_over_h, face_data);

  AssertDimension(face_data.matrix.m(), face_data.rhs.size());
  AssertDimension(face_data.matrix.n(), face_data.dof_indices_column.size());

  if(discrete_solution)
  {
    Vector<double> dof_values(face_data.dof_indices_column.size());
    std::transform(face_data.dof_indices_column.cbegin(),
                   face_data.dof_indices_column.cend(),
                   dof_values.begin(),
                   [&](const auto dof_index) { return (*discrete_solution)[dof_index]; });

    Vector<double> Ax(face_data.rhs.size());
    face_data.matrix.vmult(Ax, dof_values); // Ax
    face_data.rhs -= Ax;                    // f - Ax
  }
}



template<int dim, bool is_multigrid, bool is_simplified>
void
MatrixIntegrator<dim, is_multigrid, is_simplified>::boundary_worker(const IteratorType & cell,
                                                                    const unsigned int & face_no,
                                                                    ScratchData<dim> & scratch_data,
                                                                    CopyData & copy_data) const
{
  FEInterfaceValues<dim> & fe_interface_values = scratch_data.fe_interface_values_test;
  fe_interface_values.reinit(cell, face_no);

  const FEFaceValuesBase<dim> & phi = fe_interface_values.get_fe_face_values(0);

  const unsigned int n_dofs = phi.dofs_per_cell;

  CopyData::FaceData & face_data = copy_data.face_data.emplace_back(n_dofs);

  cell->get_active_or_mg_dof_indices(face_data.dof_indices);
  face_data.dof_indices_column = face_data.dof_indices;

  const auto h = cell->extent_in_direction(GeometryInfo<dim>::unit_normal_direction[face_no]);
  /// TODO non-uniform meshes...
  const auto   nh           = h;
  const auto   fe_degree    = scratch_data.fe_values_test.get_fe().degree;
  const double gamma_over_h = equation_data.ip_factor * compute_penalty_impl(fe_degree, h, nh);

  boundary_or_uniface_worker_impl<false>(phi, phi, gamma_over_h, face_data);

  AssertDimension(face_data.matrix.m(), n_dofs);
  AssertDimension(face_data.matrix.n(), n_dofs);
}



template<int dim, bool is_multigrid, bool is_simplified>
void
MatrixIntegrator<dim, is_multigrid, is_simplified>::boundary_worker_stream(
  const IteratorType & cell,
  const unsigned int & face_no,
  ScratchData<dim> &   scratch_data,
  CopyData &           copy_data) const
{
  scratch_data.stream_interface_values.reinit(cell, face_no);
  const auto & phi = scratch_data.stream_interface_values.get_face_values(0);

  const unsigned int n_dofs = phi.n_dofs_per_cell();

  CopyData::FaceData & face_data = copy_data.face_data.emplace_back(n_dofs);

  cell->get_active_or_mg_dof_indices(face_data.dof_indices);

  const auto h = cell->extent_in_direction(GeometryInfo<dim>::unit_normal_direction[face_no]);
  /// TODO non-uniform meshes...
  const auto   nh           = h;
  const auto   fe_degree    = scratch_data.fe_values_test.get_fe().degree;
  const double gamma_over_h = equation_data.ip_factor * compute_penalty_impl(fe_degree, h, nh);

  boundary_or_uniface_worker_impl<false>(phi, phi, gamma_over_h, face_data);

  AssertDimension(face_data.matrix.m(), n_dofs);
  AssertDimension(face_data.matrix.n(), n_dofs);
}



template<int dim, bool is_multigrid, bool is_simplified>
void
MatrixIntegrator<dim, is_multigrid, is_simplified>::boundary_worker_tangential_stream(
  const IteratorType & cell,
  const unsigned int & face_no,
  ScratchData<dim> &   scratch_data,
  CopyData &           copy_data) const
{
  scratch_data.stream_interface_values.reinit(cell, face_no);
  const auto & phi = scratch_data.stream_interface_values.get_face_values(0);

  const unsigned int n_dofs = phi.n_dofs_per_cell();

  CopyData::FaceData & face_data = copy_data.face_data.emplace_back(n_dofs);

  cell->get_active_or_mg_dof_indices(face_data.dof_indices);

  const auto h = cell->extent_in_direction(GeometryInfo<dim>::unit_normal_direction[face_no]);
  /// TODO non-uniform meshes...
  const auto   nh           = h;
  const auto   fe_degree    = scratch_data.fe_values_test.get_fe().degree;
  const double gamma_over_h = equation_data.ip_factor * compute_penalty_impl(fe_degree, h, nh);

  boundary_or_uniface_worker_tangential_impl<false>(phi, phi, gamma_over_h, face_data);

  AssertDimension(face_data.matrix.m(), n_dofs);
  AssertDimension(face_data.matrix.n(), n_dofs);
}



/// TODO remove if completely obsolete
// template<int dim, bool is_multigrid, bool is_simplified>
// template<bool do_rhs, typename TestEvaluatorType, typename AnsatzEvaluatorType>
// void
// MatrixIntegrator<dim, is_multigrid, is_simplified>::boundary_worker_impl(
//   const TestEvaluatorType &   phi_test,
//   const AnsatzEvaluatorType & phi_ansatz,
//   const double                gamma_over_h,
//   CopyData::FaceData &        face_data) const
// {
//   const auto n_interface_dofs_test   = phi_test.n_current_interface_dofs();
//   const auto n_interface_dofs_ansatz = phi_ansatz.n_current_interface_dofs();

//   AssertDimension(face_data.matrix.m(), n_interface_dofs_test);
//   AssertDimension(face_data.matrix.n(), n_interface_dofs_ansatz);

//   std::vector<Tensor<1, dim>>         solution_values;
//   const std::vector<Tensor<1, dim>> & normals = phi_test.get_normal_vectors();
//   if(do_rhs)
//   {
//     Assert(analytical_solution, ExcMessage("analytical_solution is not set."));
//     AssertDimension(analytical_solution->n_components, dim);
//     AssertDimension(face_data.rhs.size(), n_interface_dofs_test);
//     const auto & q_points = phi_test.get_quadrature_points();
//     std::transform(q_points.cbegin(),
//                    q_points.cend(),
//                    std::back_inserter(solution_values),
//                    [this](const auto & x_q) {
//                      Tensor<1, dim> value;
//                      for(auto c = 0U; c < dim; ++c)
//                        value[c] = analytical_solution->value(x_q, c);
//                      return value;
//                    });
//   }

//   double integral_ijq = 0.;
//   double nitsche_iq   = 0.;
//   for(unsigned int q = 0; q < phi_test.n_quadrature_points; ++q)
//   {
//     const auto n = normals[q];
//     for(unsigned int i = 0; i < n_interface_dofs_test; ++i)
//     {
//       if(!is_simplified)
//       {
//         const auto & av_symgrad_phi_i   = compute_average_symgrad(phi_test, i, q);
//         const auto & jump_phi_i         = compute_vjump(phi_test, i, q);
//         const auto & jump_phi_i_cross_n = outer_product(jump_phi_i, n);

//         for(unsigned int j = 0; j < n_interface_dofs_ansatz; ++j)
//         {
//           const auto & av_symgrad_phi_j   = compute_average_symgrad(phi_ansatz, j, q);
//           const auto & jump_phi_j         = compute_vjump(phi_ansatz, j, q);
//           const auto & jump_phi_j_cross_n = outer_product(jump_phi_j, n);

//           integral_ijq = -scalar_product(av_symgrad_phi_j, jump_phi_i_cross_n);
//           integral_ijq += -scalar_product(jump_phi_j_cross_n, av_symgrad_phi_i);
//           integral_ijq += gamma_over_h * jump_phi_j * jump_phi_i;
//           integral_ijq *= 2. * phi_test.JxW(q);

//           face_data.matrix(i, j) += integral_ijq;
//         }

//         /// Nitsche method (weak Dirichlet conditions)
//         if(do_rhs)
//         {
//           const auto & u         = solution_values[q];
//           const auto & u_cross_n = outer_product(u, n);

//           nitsche_iq = -scalar_product(u_cross_n, av_symgrad_phi_i);
//           nitsche_iq += gamma_over_h * u * jump_phi_i;
//           nitsche_iq *= 2. * phi_test.JxW(q);

//           face_data.rhs(i) += nitsche_iq;
//         }
//       }
//       else
//       {
//         const auto & av_grad_phi_i      = compute_average_grad(phi_test, i, q);
//         const auto & jump_phi_i         = compute_vjump(phi_test, i, q);
//         const auto & jump_n_cross_phi_i = outer_product(n, jump_phi_i);

//         for(unsigned int j = 0; j < n_interface_dofs_ansatz; ++j)
//         {
//           const auto & av_grad_phi_j      = compute_average_grad(phi_ansatz, j, q);
//           const auto & jump_phi_j         = compute_vjump(phi_ansatz, j, q);
//           const auto & jump_n_cross_phi_j = outer_product(n, jump_phi_j);

//           integral_ijq = -scalar_product(av_grad_phi_j, jump_n_cross_phi_i);
//           integral_ijq += -scalar_product(jump_n_cross_phi_j, av_grad_phi_i);
//           integral_ijq += gamma_over_h * jump_phi_j * jump_phi_i;
//           integral_ijq *= phi_test.JxW(q);

//           face_data.matrix(i, j) += integral_ijq;
//         }

//         /// Nitsche method (weak Dirichlet conditions)
//         if(do_rhs)
//         {
//           const auto & u         = solution_values[q];
//           const auto & n_cross_u = outer_product(n, u);

//           nitsche_iq = -scalar_product(n_cross_u, av_grad_phi_i);
//           nitsche_iq += gamma_over_h * u * jump_phi_i;
//           nitsche_iq *= phi_test.JxW(q);

//           face_data.rhs(i) += nitsche_iq;
//         }
//       }
//     }
//   }
// }



/// TODO remove if completely obsolete !!!
template<int dim, bool is_multigrid, bool is_simplified>
template<typename TestEvaluatorType, typename AnsatzEvaluatorType>
void
MatrixIntegrator<dim, is_multigrid, is_simplified>::uniface_worker_impl(
  const TestEvaluatorType &   phi_test,
  const AnsatzEvaluatorType & phi_ansatz,
  const double                gamma_over_h,
  CopyData::FaceData &        face_data) const
{
  const std::vector<Tensor<1, dim>> & normals = phi_test.get_normal_vectors();

  double integral_ijq = 0.;
  for(unsigned int q = 0; q < phi_test.n_quadrature_points; ++q)
  {
    const auto n = normals[q];
    for(unsigned int i = 0; i < face_data.matrix.m(); ++i)
    {
      const auto & av_symgrad_phi_i   = 0.5 * compute_symgrad(phi_test, i, q);
      const auto & jump_phi_i         = compute_vvalue(phi_test, i, q);
      const auto & jump_phi_i_cross_n = outer_product(jump_phi_i, n);

      for(unsigned int j = 0; j < face_data.matrix.n(); ++j)
      {
        const auto & av_symgrad_phi_j   = 0.5 * compute_symgrad(phi_ansatz, j, q);
        const auto & jump_phi_j         = compute_vvalue(phi_ansatz, j, q);
        const auto & jump_phi_j_cross_n = outer_product(jump_phi_j, n);

        integral_ijq = -scalar_product(av_symgrad_phi_j, jump_phi_i_cross_n);
        integral_ijq += -scalar_product(jump_phi_j_cross_n, av_symgrad_phi_i);
        integral_ijq += gamma_over_h * jump_phi_j * jump_phi_i;
        integral_ijq *= 2. * phi_test.JxW(q);

        face_data.matrix(i, j) += integral_ijq;
      }
    }
  }
}



template<int dim, bool is_multigrid, bool is_simplified>
template<bool is_uniface, typename TestEvaluatorType, typename AnsatzEvaluatorType>
void
MatrixIntegrator<dim, is_multigrid, is_simplified>::boundary_or_uniface_worker_impl(
  const TestEvaluatorType &   phi_test,
  const AnsatzEvaluatorType & phi_ansatz,
  const double                gamma_over_h,
  CopyData::FaceData &        face_data) const
{
  constexpr bool do_rhs = !is_multigrid && !is_uniface;

  const std::vector<Tensor<1, dim>> & normals = phi_test.get_normal_vectors();

  std::vector<Tensor<1, dim>> solution_values;
  if(do_rhs)
  {
    Assert(analytical_solution, ExcMessage("analytical_solution is not set."));
    AssertDimension(analytical_solution->n_components, dim);
    const auto & q_points = phi_test.get_quadrature_points();
    std::transform(q_points.cbegin(),
                   q_points.cend(),
                   std::back_inserter(solution_values),
                   [this](const auto & x_q) {
                     Tensor<1, dim> value;
                     for(auto c = 0U; c < dim; ++c)
                       value[c] = analytical_solution->value(x_q, c);
                     return value;
                   });
  }

  double integral_ijq = 0.;
  double nitsche_iq   = 0.;
  for(unsigned int q = 0; q < phi_test.n_quadrature_points; ++q)
  {
    const auto n = normals[q];
    for(unsigned int i = 0; i < face_data.matrix.m(); ++i)
    {
      if(!is_simplified)
      {
        const auto & av_symgrad_phi_i   = (is_uniface ? 0.5 : 1.) * compute_symgrad(phi_test, i, q);
        const auto & jump_phi_i         = compute_vvalue(phi_test, i, q);
        const auto & jump_phi_i_cross_n = outer_product(jump_phi_i, n);

        for(unsigned int j = 0; j < face_data.matrix.n(); ++j)
        {
          const auto & av_symgrad_phi_j =
            (is_uniface ? 0.5 : 1.) * compute_symgrad(phi_ansatz, j, q);
          const auto & jump_phi_j         = compute_vvalue(phi_ansatz, j, q);
          const auto & jump_phi_j_cross_n = outer_product(jump_phi_j, n);

          integral_ijq = -scalar_product(av_symgrad_phi_j, jump_phi_i_cross_n);
          integral_ijq += -scalar_product(jump_phi_j_cross_n, av_symgrad_phi_i);
          integral_ijq += gamma_over_h * jump_phi_j * jump_phi_i;
          integral_ijq *= 2. * phi_test.JxW(q);

          face_data.matrix(i, j) += integral_ijq;
        }

        /// Nitsche method (weak Dirichlet conditions)
        if(do_rhs)
        {
          const auto & u         = solution_values[q];
          const auto & u_cross_n = outer_product(u, n);

          nitsche_iq = -scalar_product(u_cross_n, av_symgrad_phi_i);
          nitsche_iq += gamma_over_h * u * jump_phi_i;
          nitsche_iq *= 2. * phi_test.JxW(q);

          face_data.rhs(i) += nitsche_iq;
        }
      }
      else
      {
        const auto & av_grad_phi_i      = (is_uniface ? 0.5 : 1.) * compute_grad(phi_test, i, q);
        const auto & jump_phi_i         = compute_vvalue(phi_test, i, q);
        const auto & jump_n_cross_phi_i = outer_product(n, jump_phi_i);

        for(unsigned int j = 0; j < face_data.matrix.n(); ++j)
        {
          const auto & av_grad_phi_j = (is_uniface ? 0.5 : 1.) * compute_grad(phi_ansatz, j, q);
          const auto & jump_phi_j    = compute_vvalue(phi_ansatz, j, q);
          const auto & jump_n_cross_phi_j = outer_product(n, jump_phi_j);

          integral_ijq = -scalar_product(av_grad_phi_j, jump_n_cross_phi_i);
          integral_ijq += -scalar_product(jump_n_cross_phi_j, av_grad_phi_i);
          integral_ijq += gamma_over_h * jump_phi_j * jump_phi_i;
          integral_ijq *= phi_test.JxW(q);

          face_data.matrix(i, j) += integral_ijq;
        }

        /// Nitsche method (weak Dirichlet conditions)
        if(do_rhs)
        {
          const auto & u         = solution_values[q];
          const auto & n_cross_u = outer_product(n, u);

          nitsche_iq = -scalar_product(n_cross_u, av_grad_phi_i);
          nitsche_iq += gamma_over_h * u * jump_phi_i;
          nitsche_iq *= phi_test.JxW(q);

          face_data.rhs(i) += nitsche_iq;
        }
      }
    }
  }
}



template<int dim, bool is_multigrid, bool is_simplified>
void
MatrixIntegrator<dim, is_multigrid, is_simplified>::uniface_worker(const IteratorType & cell,
                                                                   const unsigned int & face_no,
                                                                   const unsigned int & sface_no,
                                                                   ScratchData<dim> & scratch_data,
                                                                   CopyData & copy_data) const
{
  scratch_data.fe_interface_values_test.reinit(cell, face_no, sface_no, cell, face_no, sface_no);
  const FEFaceValuesBase<dim> & phi = scratch_data.fe_interface_values_test.get_fe_face_values(0);

  const unsigned int n_dofs = phi.dofs_per_cell;

  CopyData::FaceData & face_data = copy_data.face_data.emplace_back(n_dofs);

  cell->get_active_or_mg_dof_indices(face_data.dof_indices);
  face_data.dof_indices_column = face_data.dof_indices;

  const auto h = cell->extent_in_direction(GeometryInfo<dim>::unit_normal_direction[face_no]);
  /// TODO non-uniform meshes...
  const auto   nh        = h;
  const auto   fe_degree = scratch_data.fe_values_test.get_fe().degree;
  const double gamma_over_h =
    equation_data.ip_factor * 0.5 * compute_penalty_impl(fe_degree, h, nh);

  boundary_or_uniface_worker_impl<true>(phi, phi, gamma_over_h, face_data);

  AssertDimension(face_data.matrix.m(), n_dofs);
  AssertDimension(face_data.matrix.n(), n_dofs);
}



template<int dim, bool is_multigrid, bool is_simplified>
void
MatrixIntegrator<dim, is_multigrid, is_simplified>::uniface_worker_stream(
  const IteratorType & cell,
  const unsigned int & f,
  const unsigned int & sf,
  ScratchData<dim> &   scratch_data,
  CopyData &           copy_data) const
{
  auto & stream_interface_values = scratch_data.stream_interface_values;
  stream_interface_values.reinit(cell, f, sf, cell, f, sf);

  const auto & phi = stream_interface_values.get_face_values(0);

  const unsigned int n_dofs = phi.n_dofs_per_cell();

  CopyData::FaceData & face_data = copy_data.face_data.emplace_back(n_dofs);

  cell->get_active_or_mg_dof_indices(face_data.dof_indices);
  face_data.dof_indices_column = face_data.dof_indices;

  const auto h = cell->extent_in_direction(GeometryInfo<dim>::unit_normal_direction[f]);
  /// TODO non-uniform meshes...
  const auto   nh        = h;
  const auto   fe_degree = phi.get_fe().degree;
  const double gamma_over_h =
    equation_data.ip_factor * 0.5 * compute_penalty_impl(fe_degree, h, nh);

  boundary_or_uniface_worker_impl<true>(phi, phi, gamma_over_h, face_data);

  AssertDimension(face_data.matrix.m(), n_dofs);
  AssertDimension(face_data.matrix.n(), n_dofs);
}



template<int dim, bool is_multigrid, bool is_simplified>
void
MatrixIntegrator<dim, is_multigrid, is_simplified>::uniface_residual_worker_tangential(
  const IteratorType &     cell,
  const IteratorType &     cell_stream,
  const IteratorType &     cell_pressure,
  const unsigned int &     face_no,
  const unsigned int &     sface_no,
  ScratchData<dim, true> & scratch_data,
  CopyData &               copy_data) const
{
  boundary_or_uniface_residual_worker_tangential<true>(
    cell, cell_stream, cell_pressure, face_no, sface_no, scratch_data, copy_data);
}



template<int dim, bool is_multigrid, bool is_simplified>
void
MatrixIntegrator<dim, is_multigrid, is_simplified>::uniface_residual_worker_tangential_interface(
  const IteratorType &     cell,
  const IteratorType &     cell_stream,
  const unsigned int &     face_no,
  const unsigned int &     sface_no,
  ScratchData<dim, true> & scratch_data,
  CopyData &               copy_data) const
{
  boundary_or_uniface_residual_worker_tangential_interface<true>(
    cell, cell_stream, face_no, sface_no, scratch_data, copy_data);
}



template<int dim, bool is_multigrid, bool is_simplified>
void
MatrixIntegrator<dim, is_multigrid, is_simplified>::boundary_worker_tangential(
  const IteratorType & cell,
  const unsigned int & f,
  ScratchData<dim> &   scratch_data,
  CopyData &           copy_data) const
{
  scratch_data.fe_interface_values_test.reinit(cell, f);
  auto & phi = scratch_data.fe_interface_values_test.get_fe_face_values(0);

  const unsigned int n_dofs = phi.dofs_per_cell;

  CopyData::FaceData & face_data = copy_data.face_data.emplace_back(n_dofs);

  cell->get_active_or_mg_dof_indices(face_data.dof_indices);
  face_data.dof_indices_column = face_data.dof_indices;

  const auto   h         = cell->extent_in_direction(GeometryInfo<dim>::unit_normal_direction[f]);
  const auto   fe_degree = phi.get_fe().degree;
  const double gamma_over_h = equation_data.ip_factor * compute_penalty_impl(fe_degree, h, h);

  boundary_or_uniface_worker_tangential_impl<false>(phi, phi, gamma_over_h, face_data);
}



template<int dim, bool is_multigrid, bool is_simplified>
template<bool is_uniface>
void
MatrixIntegrator<dim, is_multigrid, is_simplified>::boundary_or_uniface_residual_worker_tangential(
  const IteratorType &     cell,
  const IteratorType &     cell_stream,
  const IteratorType &     cell_pressure,
  const unsigned int &     face_no,
  const unsigned int &     sface_no,
  ScratchData<dim, true> & scratch_data,
  CopyData &               copy_data) const
{
  (void)sface_no;

  scratch_data.test_interface_values.reinit(cell, face_no);
  const auto & phi_test = scratch_data.test_interface_values.get_face_values(0);

  scratch_data.stream_interface_values_ansatz.reinit(cell_stream, face_no);
  const auto & phi_ansatz = scratch_data.stream_interface_values_ansatz.get_face_values(0);

  const unsigned int n_dofs_test   = phi_test.n_dofs_per_cell();
  const unsigned int n_dofs_ansatz = phi_ansatz.n_dofs_per_cell();

  CopyData::FaceData & face_data = copy_data.face_data.emplace_back(n_dofs_test, n_dofs_ansatz);

  /// Skipping the first pressure dof which defines the constant mode (if
  /// Legendre-like).
  const auto & make_dof_indices_skipping_first = [](const auto & cell) {
    std::vector<types::global_dof_index> all(cell->get_fe().dofs_per_cell);
    cell->get_active_or_mg_dof_indices(all);
    return std::vector<types::global_dof_index>(all.begin() + 1, all.end());
  };
  face_data.dof_indices = std::move(make_dof_indices_skipping_first(cell_pressure));

  cell_stream->get_active_or_mg_dof_indices(face_data.dof_indices_column);

  const auto   h  = cell->extent_in_direction(GeometryInfo<dim>::unit_normal_direction[face_no]);
  const auto   nh = h;
  const auto   fe_degree = phi_ansatz.get_fe().degree; // stream function degree !
  const double gamma_over_h =
    (is_uniface ? 0.5 : 1.0) * equation_data.ip_factor * compute_penalty_impl(fe_degree, h, nh);

  boundary_or_uniface_worker_tangential_impl<is_uniface>(phi_test,
                                                         phi_ansatz,
                                                         gamma_over_h,
                                                         face_data);

  if(discrete_solution)
  {
    Vector<double> dof_values(face_data.dof_indices_column.size());
    std::transform(face_data.dof_indices_column.cbegin(),
                   face_data.dof_indices_column.cend(),
                   dof_values.begin(),
                   [&](const auto dof_index) { return (*discrete_solution)[dof_index]; });

    AssertDimension(face_data.matrix.n(), dof_values.size());
    AssertDimension(face_data.matrix.m(), face_data.rhs.size());
    Vector<double> Ax(face_data.rhs.size());
    face_data.matrix.vmult(Ax, dof_values); // Ax
    face_data.rhs -= Ax;                    // f - Ax
  }
}



template<int dim, bool is_multigrid, bool is_simplified>
template<bool is_uniface>
void
MatrixIntegrator<dim, is_multigrid, is_simplified>::
  boundary_or_uniface_residual_worker_tangential_interface(const IteratorType &     cell,
                                                           const IteratorType &     cell_stream,
                                                           const unsigned int &     face_no,
                                                           const unsigned int &     sface_no,
                                                           ScratchData<dim, true> & scratch_data,
                                                           CopyData &               copy_data) const
{
  (void)sface_no;

  auto [active_face_numbers_left, global_interface_indices_left] =
    get_active_interface_indices(cell);

  std::vector<std::array<unsigned int, 2>> active_joint_indices;
  for(const auto li : active_face_numbers_left)
    active_joint_indices.push_back({li, numbers::invalid_unsigned_int});

  /// Restricting TestFunction::InterfaceValues to those test functions which are active
  /// on associated "outflow" interfaces for this cell.
  scratch_data.test_interface_values.reinit(cell, face_no, active_joint_indices);
  const auto & phi_test = scratch_data.test_interface_values.get_face_values(0);

  AssertDimension(phi_test.shape_to_test_functions.m(), GeometryInfo<dim>::faces_per_cell);

  scratch_data.stream_interface_values_ansatz.reinit(cell_stream, face_no);
  const auto & phi_ansatz = scratch_data.stream_interface_values_ansatz.get_face_values(0);

  const unsigned int n_dofs_test   = phi_test.n_dofs_per_cell();
  const unsigned int n_dofs_ansatz = phi_ansatz.n_dofs_per_cell();

  CopyData::FaceData & face_data = copy_data.face_data.emplace_back(n_dofs_test, n_dofs_ansatz);

  face_data.dof_indices = std::move(global_interface_indices_left);

  AssertDimension(face_data.dof_indices.size(), active_joint_indices.size());

  cell_stream->get_active_or_mg_dof_indices(face_data.dof_indices_column);
  // face_data.dof_indices_column = phi_ansatz.get_interface_dof_indices();

  const auto   h  = cell->extent_in_direction(GeometryInfo<dim>::unit_normal_direction[face_no]);
  const auto   nh = h;
  const auto   fe_degree = phi_ansatz.get_fe().degree; // stream function degree !
  const double gamma_over_h =
    (is_uniface ? 0.5 : 1.0) * equation_data.ip_factor * compute_penalty_impl(fe_degree, h, nh);

  boundary_or_uniface_worker_tangential_impl<is_uniface>(phi_test,
                                                         phi_ansatz,
                                                         gamma_over_h,
                                                         face_data);

  AssertDimension(face_data.matrix.m(), face_data.rhs.size());
  AssertDimension(face_data.matrix.n(), face_data.dof_indices_column.size());

  if(discrete_solution)
  {
    Vector<double> dof_values(face_data.dof_indices_column.size());
    std::transform(face_data.dof_indices_column.cbegin(),
                   face_data.dof_indices_column.cend(),
                   dof_values.begin(),
                   [&](const auto dof_index) { return (*discrete_solution)[dof_index]; });

    Vector<double> Ax(face_data.rhs.size());
    face_data.matrix.vmult(Ax, dof_values); // Ax
    face_data.rhs -= Ax;                    // f - Ax
  }
}



template<int dim, bool is_multigrid, bool is_simplified>
void
MatrixIntegrator<dim, is_multigrid, is_simplified>::boundary_residual_worker_tangential(
  const IteratorType &     cell,
  const IteratorType &     cell_stream,
  const IteratorType &     cell_pressure,
  const unsigned int &     face_no,
  ScratchData<dim, true> & scratch_data,
  CopyData &               copy_data) const
{
  boundary_or_uniface_residual_worker_tangential<false>(cell,
                                                        cell_stream,
                                                        cell_pressure,
                                                        face_no,
                                                        numbers::invalid_unsigned_int,
                                                        scratch_data,
                                                        copy_data);
}



template<int dim, bool is_multigrid, bool is_simplified>
void
MatrixIntegrator<dim, is_multigrid, is_simplified>::boundary_residual_worker_tangential_interface(
  const IteratorType &     cell,
  const IteratorType &     cell_stream,
  const unsigned int &     face_no,
  ScratchData<dim, true> & scratch_data,
  CopyData &               copy_data) const
{
  boundary_or_uniface_residual_worker_tangential_interface<false>(
    cell, cell_stream, face_no, numbers::invalid_unsigned_int, scratch_data, copy_data);
}



/// TODO remove if completely obsolete !!!
// template<int dim, bool is_multigrid, bool is_simplified>
// template<bool do_rhs, typename TestEvaluatorType, typename AnsatzEvaluatorType>
// void
// MatrixIntegrator<dim, is_multigrid, is_simplified>::boundary_worker_tangential_impl(
//   const TestEvaluatorType &   phi_test,
//   const AnsatzEvaluatorType & phi_ansatz,
//   const double                gamma_over_h,
//   CopyData::FaceData &        face_data) const
// {
//   const std::vector<Tensor<1, dim>> & normals = phi_test.get_normal_vectors();

//   std::vector<Tensor<1, dim>> solution_values;
//   std::vector<Tensor<1, dim>> tangential_solution_values;
//   if(do_rhs)
//   {
//     Assert(analytical_solution, ExcMessage("analytical_solution is not set."));
//     AssertDimension(analytical_solution->n_components, dim);
//     const auto &                        q_points = phi_test.get_quadrature_points();
//     const std::vector<Tensor<1, dim>> & normals  = phi_test.get_normal_vectors();
//     std::transform(q_points.cbegin(),
//                    q_points.cend(),
//                    std::back_inserter(solution_values),
//                    [this](const auto & x_q) {
//                      Tensor<1, dim> value;
//                      for(auto c = 0U; c < dim; ++c)
//                        value[c] = analytical_solution->value(x_q, c);
//                      return value;
//                    });
//     std::transform(solution_values.cbegin(),
//                    solution_values.cend(),
//                    normals.cbegin(),
//                    std::back_inserter(tangential_solution_values),
//                    [](const auto & u_q, const auto & normal) {
//                      return u_q - ((u_q * normal) * normal);
//                    });
//     AssertDimension(solution_values.size(), phi_test.n_quadrature_points);
//     AssertDimension(tangential_solution_values.size(), phi_test.n_quadrature_points);
//   }

//   double integral_ijq = 0.;
//   double nitsche_iq   = 0.;
//   for(unsigned int q = 0; q < phi_test.n_quadrature_points; ++q)
//   {
//     const auto & n = normals[q];
//     for(unsigned int i = 0; i < face_data.matrix.m(); ++i)
//     {
//       const auto & jump_phit_i      = compute_vjump_tangential(phi_test, i, q);
//       const auto & av_symgrad_phi_i = compute_average_symgrad(phi_test, i, q);
//       double       ncontrib_i       = n * av_symgrad_phi_i * n;

//       for(unsigned int j = 0; j < face_data.matrix.n(); ++j)
//       {
//         const auto & jump_phit_j      = compute_vjump_tangential(phi_ansatz, j, q);
//         const auto & av_symgrad_phi_j = compute_average_symgrad(phi_ansatz, j, q);
//         double       ncontrib_j       = n * av_symgrad_phi_j * n;

//         integral_ijq = -(n * av_symgrad_phi_j - ncontrib_j * n) * jump_phit_i;
//         integral_ijq += -(n * av_symgrad_phi_i - ncontrib_i * n) * jump_phit_j;
//         integral_ijq += gamma_over_h * jump_phit_j * jump_phit_i;
//         integral_ijq *= 2. * phi_test.JxW(q);

//         face_data.matrix(i, j) += integral_ijq;
//       }

//       /// Nitsche method (weak Dirichlet conditions)
//       if(do_rhs)
//       {
//         /// ut is the tangential vector field of the vector field u (which
//         /// should not be confused with the tangential component of the vector
//         /// field u!).
//         const auto & ut = tangential_solution_values[q];

//         nitsche_iq = -(n * av_symgrad_phi_i - n * ncontrib_i) * ut;
//         nitsche_iq += gamma_over_h * ut * jump_phit_i;
//         nitsche_iq *= 2. * phi_test.JxW(q);

//         face_data.rhs(i) += nitsche_iq;
//       }
//     }
//   }
// }



template<int dim, bool is_multigrid, bool is_simplified>
template<bool is_uniface, typename TestEvaluatorType, typename AnsatzEvaluatorType>
void
MatrixIntegrator<dim, is_multigrid, is_simplified>::boundary_or_uniface_worker_tangential_impl(
  const TestEvaluatorType &   phi_test,
  const AnsatzEvaluatorType & phi_ansatz,
  const double                gamma_over_h,
  CopyData::FaceData &        face_data) const
{
  constexpr bool do_rhs = !is_multigrid && !is_uniface;

  const auto n_dofs_test   = face_data.matrix.m();
  const auto n_dofs_ansatz = face_data.matrix.n();

  AssertDimension(n_dofs_test, face_data.dof_indices.size());
  if(!face_data.dof_indices_column.empty())
    AssertDimension(n_dofs_ansatz, face_data.dof_indices_column.size());

  const std::vector<Tensor<1, dim>> & normals = phi_test.get_normal_vectors();

  std::vector<Tensor<1, dim>> tangential_solution_values;
  if(do_rhs)
  {
    Assert(analytical_solution, ExcMessage("analytical_solution is not set."));
    AssertDimension(analytical_solution->n_components, dim);
    const auto &                q_points = phi_test.get_quadrature_points();
    std::vector<Tensor<1, dim>> solution_values;
    std::transform(q_points.cbegin(),
                   q_points.cend(),
                   std::back_inserter(solution_values),
                   [this](const auto & x_q) {
                     Tensor<1, dim> value;
                     for(auto c = 0U; c < dim; ++c)
                       value[c] = analytical_solution->value(x_q, c);
                     return value;
                   });
    std::transform(solution_values.cbegin(),
                   solution_values.cend(),
                   normals.cbegin(),
                   std::back_inserter(tangential_solution_values),
                   [](const auto & u_q, const auto & normal) {
                     return u_q - ((u_q * normal) * normal);
                   });
    AssertDimension(solution_values.size(), phi_test.n_quadrature_points);
    AssertDimension(tangential_solution_values.size(), phi_test.n_quadrature_points);
  }

  double integral_ijq = 0.;
  double nitsche_iq   = 0.;
  for(unsigned int q = 0; q < phi_test.n_quadrature_points; ++q)
  {
    const auto & n = normals[q];
    for(unsigned int i = 0; i < n_dofs_test; ++i)
    {
      if(!is_simplified)
      {
        const auto & phi_i            = compute_vvalue(phi_test, i, q);
        const auto & jump_phit_i      = phi_i - ((phi_i * n) * n);
        const auto & av_symgrad_phi_i = (is_uniface ? 0.5 : 1.0) * compute_symgrad(phi_test, i, q);
        double       ncontrib_i       = n * av_symgrad_phi_i * n;

        for(unsigned int j = 0; j < n_dofs_ansatz; ++j)
        {
          const auto & phi_j       = compute_vvalue(phi_ansatz, j, q);
          const auto & jump_phit_j = phi_j - ((phi_j * n) * n);
          const auto & av_symgrad_phi_j =
            (is_uniface ? 0.5 : 1.0) * compute_symgrad(phi_ansatz, j, q);
          double ncontrib_j = n * av_symgrad_phi_j * n;

          integral_ijq = -(n * av_symgrad_phi_j - ncontrib_j * n) * jump_phit_i;
          integral_ijq += -(n * av_symgrad_phi_i - ncontrib_i * n) * jump_phit_j;
          integral_ijq += gamma_over_h * jump_phit_j * jump_phit_i;
          integral_ijq *= 2. * phi_test.JxW(q);

          face_data.matrix(i, j) += integral_ijq;
        }

        /// Nitsche method (weak Dirichlet conditions)
        if(do_rhs)
        {
          /// ut is the tangential vector field of the vector field u (which
          /// should not be confused with the tangential component of the vector
          /// field u!).
          const auto & ut = tangential_solution_values[q];

          nitsche_iq = -(n * av_symgrad_phi_i - n * ncontrib_i) * ut;
          nitsche_iq += gamma_over_h * ut * jump_phit_i;
          nitsche_iq *= 2. * phi_test.JxW(q);

          face_data.rhs(i) += nitsche_iq;
        }
      }
      else
      {
        const auto & phi_i         = compute_vvalue(phi_test, i, q);
        const auto & jump_phit_i   = phi_i - ((phi_i * n) * n);
        const auto & av_grad_phi_i = (is_uniface ? 0.5 : 1.0) * compute_grad(phi_test, i, q);
        double       ncontrib_i    = n * av_grad_phi_i * n;

        for(unsigned int j = 0; j < n_dofs_ansatz; ++j)
        {
          const auto & phi_j         = compute_vvalue(phi_ansatz, j, q);
          const auto & jump_phit_j   = phi_j - ((phi_j * n) * n);
          const auto & av_grad_phi_j = (is_uniface ? 0.5 : 1.0) * compute_grad(phi_ansatz, j, q);
          double       ncontrib_j    = n * av_grad_phi_j * n;

          integral_ijq = -(n * av_grad_phi_j - ncontrib_j * n) * jump_phit_i;
          integral_ijq += -(n * av_grad_phi_i - ncontrib_i * n) * jump_phit_j;
          integral_ijq += gamma_over_h * jump_phit_j * jump_phit_i;
          integral_ijq *= phi_test.JxW(q);

          face_data.matrix(i, j) += integral_ijq;
        }

        /// Nitsche method (weak Dirichlet conditions)
        if(do_rhs)
        {
          /// ut is the tangential vector field of the vector field u (which
          /// should not be confused with the tangential component of the vector
          /// field u!).
          const auto & ut = tangential_solution_values[q];

          nitsche_iq = -(n * av_grad_phi_i - n * ncontrib_i) * ut;
          nitsche_iq += gamma_over_h * ut * jump_phit_i;
          nitsche_iq *= phi_test.JxW(q);

          face_data.rhs(i) += nitsche_iq;
        }
      }
    }
  }
}



template<int dim, bool is_multigrid, bool is_simplified>
void
MatrixIntegrator<dim, is_multigrid, is_simplified>::uniface_worker_tangential(
  const IteratorType & cell,
  const unsigned int & f,
  const unsigned int & sf,
  ScratchData<dim> &   scratch_data,
  CopyData &           copy_data) const
{
  scratch_data.fe_interface_values_test.reinit(cell, f, sf, cell, f, sf);
  const auto & phi = scratch_data.fe_interface_values_test.get_fe_face_values(0);

  const unsigned int n_dofs = phi.dofs_per_cell;

  CopyData::FaceData & face_data = copy_data.face_data.emplace_back(n_dofs);

  cell->get_active_or_mg_dof_indices(face_data.dof_indices);

  const auto h = cell->extent_in_direction(GeometryInfo<dim>::unit_normal_direction[f]);
  /// TODO non-uniform meshes...
  const auto   nh        = h;
  const auto   fe_degree = scratch_data.fe_values_test.get_fe().degree;
  const double gamma_over_h =
    equation_data.ip_factor * 0.5 * compute_penalty_impl(fe_degree, h, nh);

  boundary_or_uniface_worker_tangential_impl<true>(phi, phi, gamma_over_h, face_data);
}



template<int dim, bool is_multigrid, bool is_simplified>
void
MatrixIntegrator<dim, is_multigrid, is_simplified>::uniface_worker_tangential_stream(
  const IteratorType & cell,
  const unsigned int & f,
  const unsigned int & sf,
  ScratchData<dim> &   scratch_data,
  CopyData &           copy_data) const
{
  scratch_data.stream_interface_values.reinit(cell, f, sf, cell, f, sf);
  const auto & phi = scratch_data.stream_interface_values.get_face_values(0);

  const unsigned int n_dofs = phi.n_dofs_per_cell();

  CopyData::FaceData & face_data = copy_data.face_data.emplace_back(n_dofs);

  cell->get_active_or_mg_dof_indices(face_data.dof_indices);
  face_data.dof_indices_column = face_data.dof_indices;

  const auto h = cell->extent_in_direction(GeometryInfo<dim>::unit_normal_direction[f]);
  /// TODO non-uniform meshes...
  const auto   nh        = h;
  const auto   fe_degree = phi.get_fe().degree;
  const double gamma_over_h =
    equation_data.ip_factor * 0.5 * compute_penalty_impl(fe_degree, h, nh);

  boundary_or_uniface_worker_tangential_impl<true>(phi, phi, gamma_over_h, face_data);

  AssertDimension(face_data.matrix.m(), n_dofs);
  AssertDimension(face_data.matrix.n(), n_dofs);
}



template<int dim, bool is_multigrid, bool is_simplified>
std::pair<std::vector<unsigned int>, std::vector<types::global_dof_index>>
MatrixIntegrator<dim, is_multigrid, is_simplified>::get_active_interface_indices(
  const IteratorType & cell) const
{
  return make_active_interface_indices_impl(*interface_handler, cell);
}

} // namespace MW



namespace FD
{
template<int dim,
         int fe_degree,
         typename Number               = double,
         TPSS::DoFLayout dof_layout    = TPSS::DoFLayout::Q,
         bool            is_simplified = false>
class MatrixIntegrator
{
public:
  using This = MatrixIntegrator<dim, fe_degree, Number, dof_layout, is_simplified>;

  static constexpr int n_q_points_1d = n_q_points_1d_impl(fe_degree, dof_layout);

  using value_type     = Number;
  using transfer_type  = typename TPSS::PatchTransfer<dim, Number>;
  using matrix_type_1d = Table<2, VectorizedArray<Number>>;
  using matrix_type    = Tensors::BlockMatrix<dim, VectorizedArray<Number>, -1, -1>;
  using evaluator_type = FDEvaluation<dim, fe_degree, n_q_points_1d, Number>;

  void
  initialize(const EquationData & equation_data_in)
  {
    equation_data = equation_data_in;
  }

  /// TODO use tangential contribution only for RT !!!
  template<typename OperatorType>
  void
  assemble_subspace_inverses(const SubdomainHandler<dim, Number> & subdomain_handler,
                             std::vector<matrix_type> &            local_matrices,
                             const OperatorType &,
                             const std::pair<unsigned int, unsigned int> subdomain_range) const
  {
    AssertDimension(subdomain_handler.get_partition_data().n_subdomains(), local_matrices.size());

    constexpr bool is_sipg =
      TPSS::DoFLayout::DGQ == dof_layout || TPSS::DoFLayout::RT == dof_layout;

    for(auto comp_test = 0U; comp_test < dim; ++comp_test)
    {
      evaluator_type eval_test(subdomain_handler, /*dofh_index*/ 0, comp_test);
      for(auto comp_ansatz = comp_test; comp_ansatz < dim; ++comp_ansatz) // assuming isotropy !
      {
        evaluator_type eval_ansatz(subdomain_handler, /*dofh_index*/ 0, comp_ansatz);
        for(unsigned int patch = subdomain_range.first; patch < subdomain_range.second; ++patch)
        {
          auto & velocity_matrix = local_matrices[patch];
          if(velocity_matrix.n_block_rows() != dim && velocity_matrix.n_block_cols() != dim)
            velocity_matrix.resize(dim, dim);

          eval_test.reinit(patch);
          eval_ansatz.reinit(patch);

          const auto mass_matrices = assemble_mass_tensor(eval_test, eval_ansatz);

          if(comp_test == comp_ansatz)
          {
            const auto laplace_matrices = assemble_laplace_tensor<is_sipg>(eval_test, eval_ansatz);

            const auto & MxMxL = [&](const unsigned int direction_of_L) {
              /// For example, we obtain MxMxL for direction_of_L = 0 (dimension
              /// 0 is rightmost!)
              std::array<matrix_type_1d, dim> kronecker_tensor;
              /// if direction_of_L equals the velocity component we scale by two
              AssertDimension(comp_test, comp_ansatz);
              const auto factor = direction_of_L == comp_ansatz && !is_simplified ? 2. : 1.;
              for(auto d = 0U; d < dim; ++d)
                kronecker_tensor[d] = d == direction_of_L ?
                                        factor * laplace_matrices[direction_of_L] :
                                        mass_matrices[d];
              return kronecker_tensor;
            };

            /// (0,0)-block: LxMxM + MxLxM + MxMx2L
            std::vector<std::array<matrix_type_1d, dim>> rank1_tensors;
            for(auto direction_of_L = 0; direction_of_L < dim; ++direction_of_L)
              rank1_tensors.emplace_back(MxMxL(direction_of_L));
            velocity_matrix.get_block(comp_test, comp_ansatz).reinit(rank1_tensors);
          }

          else
          {
            std::vector<std::array<matrix_type_1d, dim>> rank1_tensors;

            if(!is_simplified)
            {
              /// The factor 2 arising from 2 * e(u) : grad v is implicitly
              /// equalized by the factor 1/2 from the symmetrized gradient
              /// e(u). First, we emphasize that for off-diagonal blocks there
              /// are no penalty contributions. For the remaing contributions,
              /// namely consistency and symmetry terms, again the factor 2 is
              /// implicitly equalized. Nevertheless, we have to consider the
              /// factor 1/2 arising from average operators {{e(u)}} and
              /// {{e(v)}}, respectively.
              const auto gradient_matrices = assemble_gradient_tensor(eval_test, eval_ansatz);

              const auto & MxGxGT = [&](const auto component_test, const auto component_ansatz) {
                const int deriv_index_ansatz = component_test;
                const int deriv_index_test   = component_ansatz;
                Assert(deriv_index_ansatz != deriv_index_test,
                       ExcMessage("This case is not well-defined."));
                std::array<matrix_type_1d, dim> kronecker_tensor;
                for(auto d = 0; d < dim; ++d)
                {
                  if(d == deriv_index_ansatz)
                    kronecker_tensor[d] = gradient_matrices[deriv_index_ansatz];
                  else if(d == deriv_index_test)
                    kronecker_tensor[d] = LinAlg::transpose(gradient_matrices[deriv_index_test]);
                  else
                    kronecker_tensor[d] = mass_matrices[d];
                }
                return kronecker_tensor;
              };

              /// (0,1)-block: MxGxGT + MxPxG + MxGTxP
              {
                /// MxGxGT
                rank1_tensors.emplace_back(MxGxGT(comp_test, comp_ansatz));

                /// Factor 1/2 of average operator {{e(u)}} and {{e(v)}} is used
                /// within assemble_mixed_nitsche_tensor
                const auto point_mass_matrices =
                  assemble_mixed_nitsche_tensor(eval_test, eval_ansatz);

                { /// MxPxG
                  std::array<matrix_type_1d, dim> kronecker_tensor;
                  for(auto d = 0U; d < dim; ++d)
                  {
                    if(d == comp_test)
                      kronecker_tensor[d] = gradient_matrices[comp_test];
                    else if(d == comp_ansatz)
                      kronecker_tensor[d] = point_mass_matrices[comp_ansatz];
                    else
                      kronecker_tensor[d] = mass_matrices[d];
                  }
                  rank1_tensors.emplace_back(kronecker_tensor);
                }

                { /// MxGTxP
                  std::array<matrix_type_1d, dim> kronecker_tensor;
                  for(auto d = 0U; d < dim; ++d)
                  {
                    if(d == comp_test)
                      kronecker_tensor[d] = point_mass_matrices[comp_test];
                    else if(d == comp_ansatz)
                      kronecker_tensor[d] = LinAlg::transpose(gradient_matrices[comp_ansatz]);
                    else
                      kronecker_tensor[d] = mass_matrices[d];
                  }
                  rank1_tensors.emplace_back(kronecker_tensor);
                }
              }
            }
            else
            {
              std::array<unsigned int, dim> n_rows; /// assuming isotropy
              const auto                    n_dofs_1d = eval_test.get_dof_tensor().n_dofs_1d(0);
              n_rows.fill(n_dofs_1d);
              rank1_tensors =
                Tensors::make_zero_rank1_tensors<dim, VectorizedArray<Number>>(/*rank*/ 1,
                                                                               n_rows,
                                                                               n_rows);
            }

            velocity_matrix.get_block(comp_test, comp_ansatz).reinit(rank1_tensors);

            /// (1,0)-block: transpose of (0,1)-block
            {
              for(auto & tensor : rank1_tensors)
                Tensors::transpose_tensor<dim>(tensor);
              velocity_matrix.get_block(comp_ansatz, comp_test).reinit(rank1_tensors);
            }
          }
        }
      }
    }
  }

  std::array<matrix_type_1d, dim>
  assemble_mixed_nitsche_tensor(evaluator_type & eval_test, evaluator_type & eval_ansatz) const
  {
    using CellVoid = ::FD::Void::CellOperation<dim, fe_degree, n_q_points_1d, Number>;

    const auto face_point_mass = [&](const evaluator_type &              eval_ansatz,
                                     const evaluator_type &              eval_test,
                                     Table<2, VectorizedArray<Number>> & cell_matrix,
                                     const int                           direction,
                                     const int                           cell_no,
                                     const int                           face_no) {
      const int  n_dofs_test    = eval_test.n_dofs_per_cell_1d(direction);
      const int  n_dofs_ansatz  = eval_ansatz.n_dofs_per_cell_1d(direction);
      const auto normal_vector  = eval_ansatz.get_normal_vector(face_no, direction);
      const auto average_factor = eval_test.get_average_factor(direction, cell_no, face_no);
      const auto comp_u         = eval_ansatz.vector_component();
      const auto comp_v         = eval_test.vector_component();

      for(int i = 0; i < n_dofs_test; ++i)
      {
        const auto & v_i = eval_test.shape_value_face(i, face_no, direction, cell_no);
        for(int j = 0; j < n_dofs_ansatz; ++j)
        {
          const auto & u_j           = eval_ansatz.shape_value_face(j, face_no, direction, cell_no);
          const auto & value_on_face = -average_factor * (v_i * normal_vector[comp_u] * u_j +
                                                          v_i * u_j * normal_vector[comp_v]);
          cell_matrix(i, j) += value_on_face;
        }
      }
    };

    const auto interface_point_mass = [&](const evaluator_type &              eval_ansatz,
                                          const evaluator_type &              eval_test,
                                          Table<2, VectorizedArray<Number>> & cell_matrix01,
                                          Table<2, VectorizedArray<Number>> & cell_matrix10,
                                          const int                           cell_no_left,
                                          const int                           direction) {
      (void)cell_no_left;
      AssertDimension(cell_no_left, 0);
      const int  n_dofs_test    = eval_test.n_dofs_per_cell_1d(direction);
      const int  n_dofs_ansatz  = eval_ansatz.n_dofs_per_cell_1d(direction);
      const auto normal_vector0 = eval_test.get_normal_vector(1, direction); // on cell 0
      const auto normal_vector1 = eval_test.get_normal_vector(0, direction); // on cell 1
      const auto comp_u         = eval_ansatz.vector_component();
      const auto comp_v         = eval_test.vector_component();

      auto value_on_interface01{make_vectorized_array<Number>(0.)};
      auto value_on_interface10{make_vectorized_array<Number>(0.)};
      for(int i = 0; i < n_dofs_test; ++i)
      {
        const auto & v0_i = eval_test.shape_value_face(i, /*face_no*/ 1, direction, /*cell_no*/ 0);
        const auto & v1_i = eval_test.shape_value_face(i, 0, direction, 1);
        for(int j = 0; j < n_dofs_ansatz; ++j)
        {
          const auto & u0_j = eval_ansatz.shape_value_face(j, 1, direction, 0);
          const auto & u1_j = eval_ansatz.shape_value_face(j, 0, direction, 1);

          /// consistency + symmetry
          value_on_interface01 =
            -0.5 * (v0_i * normal_vector0[comp_u] * u1_j + v0_i * u1_j * normal_vector1[comp_v]);
          value_on_interface10 =
            -0.5 * (v1_i * normal_vector1[comp_u] * u0_j + v1_i * u0_j * normal_vector0[comp_v]);

          cell_matrix01(i, j) += value_on_interface01;
          cell_matrix10(i, j) += value_on_interface10;
        }
      }
    };

    return eval_test.patch_action(eval_ansatz, CellVoid{}, face_point_mass, interface_point_mass);
  }

  template<bool is_sipg = false>
  std::array<matrix_type_1d, dim>
  assemble_laplace_tensor(evaluator_type & eval_test, evaluator_type & eval_ansatz) const
  {
    using CellLaplace = ::FD::Laplace::CellOperation<dim, fe_degree, n_q_points_1d, Number>;
    CellLaplace cell_laplace;

    if constexpr(is_sipg)
    {
      using FaceLaplace = ::FD::Laplace::SIPG::FaceOperation<dim, fe_degree, n_q_points_1d, Number>;
      FaceLaplace nitsche;
      nitsche.penalty_factor          = equation_data.ip_factor;
      nitsche.interior_penalty_factor = equation_data.ip_factor;

      if(is_simplified)
        return eval_test.patch_action(eval_ansatz, cell_laplace, nitsche, nitsche);

      const auto face_nitsche_plus_penalty = [&](const evaluator_type & eval_ansatz,
                                                 const evaluator_type & eval_test,
                                                 matrix_type_1d &       cell_matrix,
                                                 const int              direction,
                                                 const int              cell_no,
                                                 const int              face_no) {
        nitsche(eval_ansatz, eval_test, cell_matrix, direction, cell_no, face_no);

        const int vector_component = eval_test.vector_component();
        AssertDimension(vector_component, static_cast<int>(eval_ansatz.vector_component()));

        if(vector_component != direction)
        {
          const int  n_dofs_test    = eval_test.n_dofs_per_cell_1d(direction);
          const int  n_dofs_ansatz  = eval_ansatz.n_dofs_per_cell_1d(direction);
          const auto average_factor = eval_test.get_average_factor(direction, cell_no, face_no);
          const auto normal         = eval_test.get_normal(face_no);

          const auto h       = eval_test.get_h(direction, cell_no);
          const auto penalty = nitsche.penalty_factor * average_factor *
                               ::Nitsche::compute_penalty_impl(fe_degree, h, h);

          auto value_on_face = make_vectorized_array<Number>(0.);
          for(int i = 0; i < n_dofs_test; ++i)
          {
            const auto & v_i = eval_test.shape_value_face(i, face_no, direction, cell_no);
            for(int j = 0; j < n_dofs_ansatz; ++j)
            {
              const auto & u_j = eval_ansatz.shape_value_face(j, face_no, direction, cell_no);
              value_on_face    = penalty * v_i * u_j * normal * normal;
              cell_matrix(i, j) += value_on_face;
            }
          }
        }
      };

      const auto interface_nitsche_plus_penalty = [&](const evaluator_type & eval_ansatz,
                                                      const evaluator_type & eval_test,
                                                      matrix_type_1d &       cell_matrix01,
                                                      matrix_type_1d &       cell_matrix10,
                                                      const int              cell_no0,
                                                      const int              direction) {
        nitsche(eval_ansatz, eval_test, cell_matrix01, cell_matrix10, cell_no0, direction);

        const int vector_component = eval_test.vector_component();
        AssertDimension(vector_component, static_cast<int>(eval_ansatz.vector_component()));

        if(vector_component != direction)
        {
          const int  n_dofs_test   = eval_test.n_dofs_per_cell_1d(direction);
          const int  n_dofs_ansatz = eval_ansatz.n_dofs_per_cell_1d(direction);
          const auto normal0       = eval_test.get_normal(1); // on cell 0
          const auto normal1       = eval_test.get_normal(0); // on cell 1

          const auto h0      = eval_test.get_h(direction, cell_no0);
          const auto h1      = eval_test.get_h(direction, cell_no0 + 1);
          const auto penalty = nitsche.interior_penalty_factor * 0.5 *
                               ::Nitsche::compute_penalty_impl(fe_degree, h0, h1);

          auto value_on_interface01 = make_vectorized_array<Number>(0.);
          auto value_on_interface10 = make_vectorized_array<Number>(0.);
          for(int i = 0; i < n_dofs_test; ++i)
          {
            const auto & v0_i = eval_test.shape_value_face(i, 1, direction, 0);
            const auto & v1_i = eval_test.shape_value_face(i, 0, direction, 1);
            for(int j = 0; j < n_dofs_ansatz; ++j)
            {
              const auto & u0_j    = eval_ansatz.shape_value_face(j, 1, direction, 0);
              const auto & u1_j    = eval_ansatz.shape_value_face(j, 0, direction, 1);
              value_on_interface01 = penalty * v0_i * u1_j * normal0 * normal1;
              value_on_interface10 = penalty * v1_i * u0_j * normal1 * normal0;
              cell_matrix01(i, j) += value_on_interface01;
              cell_matrix10(i, j) += value_on_interface10;
            }
          }
        }
      };

      return eval_test.patch_action(eval_ansatz,
                                    cell_laplace,
                                    face_nitsche_plus_penalty,
                                    interface_nitsche_plus_penalty);
    }

    return eval_test.patch_action(eval_ansatz, cell_laplace);
  }

  std::array<matrix_type_1d, dim>
  assemble_mass_tensor(evaluator_type & eval_test, evaluator_type & eval_ansatz) const
  {
    using CellMass = ::FD::L2::CellOperation<dim, fe_degree, n_q_points_1d, Number>;
    return eval_test.patch_action(eval_ansatz, CellMass{});
  }

  std::array<matrix_type_1d, dim>
  assemble_gradient_tensor(evaluator_type & eval_test, evaluator_type & eval_ansatz) const
  {
    using CellGradient = ::FD::Gradient::CellOperation<dim, fe_degree, n_q_points_1d, Number>;
    CellGradient cell_gradient;
    return eval_test.patch_action(eval_ansatz, cell_gradient);
  }

  std::shared_ptr<transfer_type>
  get_patch_transfer(const SubdomainHandler<dim, Number> & subdomain_handler) const
  {
    return std::make_shared<transfer_type>(subdomain_handler, 0);
  }

  EquationData equation_data;
};

} // end namespace FD

} // end namespace SIPG

} // namespace Velocity



namespace Pressure
{
namespace MW
{
using ::MW::ScratchData;

using ::MW::DoF::CopyData;

template<int dim, bool is_multigrid = false>
struct MatrixIntegrator
{
  using IteratorType = typename ::MW::IteratorSelector<dim, is_multigrid>::type;

  MatrixIntegrator(const Function<dim> *                              load_function_in,
                   const Function<dim> *                              analytical_solution_in,
                   const LinearAlgebra::distributed::Vector<double> * particular_solution,
                   const EquationData &                               equation_data_in)
    : load_function(load_function_in),
      analytical_solution(analytical_solution_in),
      discrete_solution(particular_solution),
      equation_data(equation_data_in)
  {
  }

  void
  cell_worker(const IteratorType & cell,
              ScratchData<dim> &   scratch_data,
              CopyData &           copy_data) const;

  void
  cell_mass_worker(const IteratorType & cell,
                   ScratchData<dim> &   scratch_data,
                   CopyData &           copy_data) const;

  const Function<dim> *                              load_function;
  const Function<dim> *                              analytical_solution;
  const LinearAlgebra::distributed::Vector<double> * discrete_solution;
  const EquationData                                 equation_data;
};

template<int dim, bool is_multigrid>
void
MatrixIntegrator<dim, is_multigrid>::cell_worker(const IteratorType & cell,
                                                 ScratchData<dim> &   scratch_data,
                                                 CopyData &           copy_data) const
{
  AssertDimension(copy_data.cell_data.size(), 0U);

  FEValues<dim> & phi = scratch_data.fe_values;
  phi.reinit(cell);

  const unsigned int dofs_per_cell = phi.get_fe().dofs_per_cell;

  auto & cell_data = copy_data.cell_data.emplace_back(dofs_per_cell);

  cell->get_active_or_mg_dof_indices(cell_data.dof_indices);

  AssertDimension(load_function->n_components, 1U);

  const auto & quadrature_points = phi.get_quadrature_points();
  for(unsigned int q = 0; q < phi.n_quadrature_points; ++q)
  {
    const auto & x_q = quadrature_points[q];
    for(unsigned int i = 0; i < dofs_per_cell; ++i)
    {
      if(!is_multigrid)
      {
        const auto load_value = load_function->value(x_q);
        cell_data.rhs(i) += phi.shape_value(i, q) * load_value * phi.JxW(q);
      }
    }
  }
}

template<int dim, bool is_multigrid>
void
MatrixIntegrator<dim, is_multigrid>::cell_mass_worker(const IteratorType & cell,
                                                      ScratchData<dim> &   scratch_data,
                                                      CopyData &           copy_data) const
{
  AssertDimension(copy_data.cell_data.size(), 0U);

  FEValues<dim> & phi = scratch_data.fe_values;
  phi.reinit(cell);

  const unsigned int dofs_per_cell = phi.get_fe().dofs_per_cell;

  auto & cell_data = copy_data.cell_data.emplace_back(dofs_per_cell);

  cell->get_active_or_mg_dof_indices(cell_data.dof_indices);

  for(unsigned int q = 0; q < phi.n_quadrature_points; ++q)
    for(unsigned int i = 0; i < dofs_per_cell; ++i)
      for(unsigned int j = 0; j < dofs_per_cell; ++j)
        cell_data.matrix(i, j) += phi.shape_value(i, q) * phi.shape_value(j, q) * phi.JxW(q);
}

} // namespace MW

} // namespace Pressure



namespace VelocityPressure
{
namespace MW
{
using ::MW::ScratchData;

using ::MW::CopyData;



template<int dim, bool is_multigrid = false>
struct MatrixIntegrator
{
  static_assert(!is_multigrid, "not implemented.");

  using IteratorType = typename ::MW::IteratorSelector<dim, is_multigrid>::type;

  MatrixIntegrator(const Function<dim> *                                   load_function_in,
                   const Function<dim> *                                   analytical_solution_in,
                   const LinearAlgebra::distributed::BlockVector<double> * particular_solution,
                   const EquationData &                                    equation_data_in)
    : load_function(load_function_in),
      analytical_solution(analytical_solution_in),
      discrete_solution(particular_solution),
      equation_data(equation_data_in)
  {
  }

  void
  cell_worker(const IteratorType & cell,
              ScratchData<dim> &   scratch_data,
              CopyData &           copy_data) const
  {
    copy_data.cell_matrix = 0.;
    copy_data.cell_rhs    = 0.;

    FEValues<dim> & fe_values = scratch_data.fe_values;
    fe_values.reinit(cell);
    cell->get_active_or_mg_dof_indices(copy_data.local_dof_indices);
    const auto &       fe            = fe_values.get_fe();
    const unsigned int dofs_per_cell = fe.dofs_per_cell;
    const unsigned int n_q_points    = fe_values.n_quadrature_points;

    std::vector<Vector<double>> rhs_values(n_q_points, Vector<double>(dim + 1));

    const FEValuesExtractors::Vector velocities(0);
    const FEValuesExtractors::Scalar pressure(dim);

    std::vector<SymmetricTensor<2, dim>> symgrad_phi_u(dofs_per_cell);
    std::vector<double>                  div_phi_u(dofs_per_cell);
    std::vector<double>                  phi_p(dofs_per_cell);

    load_function->vector_value_list(fe_values.get_quadrature_points(), rhs_values);

    for(unsigned int q = 0; q < n_q_points; ++q)
    {
      for(unsigned int k = 0; k < dofs_per_cell; ++k)
      {
        symgrad_phi_u[k] = fe_values[velocities].symmetric_gradient(k, q);
        div_phi_u[k]     = fe_values[velocities].divergence(k, q);
        phi_p[k]         = fe_values[pressure].value(k, q);
      }

      for(unsigned int i = 0; i < dofs_per_cell; ++i)
      {
        for(unsigned int j = 0; j <= i; ++j)
        {
          copy_data.cell_matrix(i, j) +=
            (2 * (symgrad_phi_u[i] * symgrad_phi_u[j]) - div_phi_u[i] * phi_p[j] -
             phi_p[i] * div_phi_u[j] +
             (equation_data.assemble_pressure_mass_matrix ? phi_p[i] * phi_p[j] : 0)) *
            fe_values.JxW(q);
        }

        const unsigned int component_i = fe.system_to_component_index(i).first;
        copy_data.cell_rhs(i) +=
          fe_values.shape_value(i, q) * rhs_values[q](component_i) * fe_values.JxW(q);
      }
    }

    for(unsigned int i = 0; i < dofs_per_cell; ++i)
      for(unsigned int j = i + 1; j < dofs_per_cell; ++j)
        copy_data.cell_matrix(i, j) = copy_data.cell_matrix(j, i);

    if(discrete_solution)
    {
      Vector<double> u0(copy_data.local_dof_indices.size());
      for(auto i = 0U; i < u0.size(); ++i)
        u0(i) = (*discrete_solution)(copy_data.local_dof_indices[i]);
      Vector<double> w0(copy_data.local_dof_indices.size());
      copy_data.cell_matrix.vmult(w0, u0);
      copy_data.cell_rhs -= w0;
    }
  }

  const Function<dim> *                                   load_function;
  const Function<dim> *                                   analytical_solution;
  const LinearAlgebra::distributed::BlockVector<double> * discrete_solution;
  const EquationData                                      equation_data;
};



namespace Mixed
{
using ::MW::compute_vvalue;

using ::MW::compute_vjump;

using ::MW::compute_vjump_dot_normal;

using ::MW::compute_divergence;

using ::MW::Mixed::ScratchData;

using CopyData = std::array<::MW::DoF::CopyData, 2>;

template<int dim, bool is_multigrid = false>
struct MatrixIntegrator
{
  using IteratorType = typename ::MW::IteratorSelector<dim, is_multigrid>::type;

  MatrixIntegrator(const LinearAlgebra::distributed::Vector<double> * particular_solutionU,
                   const LinearAlgebra::distributed::Vector<double> * particular_solutionP,
                   const Function<dim> *                              analytical_solutionU_in,
                   const Function<dim> *                              analytical_solutionP_in,
                   const EquationData &                               equation_data_in)
    : discrete_solutionU(particular_solutionU),
      discrete_solutionP(particular_solutionP),
      analytical_solutionU(analytical_solutionU_in),
      analytical_solutionP(analytical_solutionP_in),
      equation_data(equation_data_in)
  {
    AssertThrow(
      !particular_solutionP,
      ExcMessage(
        "There is currently no reason to set particular_solutionP, as it should be a vector filled with zeros!"));
    AssertThrow(
      !analytical_solutionP,
      ExcMessage(
        "There is currently no reason to set analytical_solutionP, as it is not used by the bilinear form!"));
  }

  void
  cell_worker(const IteratorType & cellU,
              const IteratorType & cellP,
              ScratchData<dim> &   scratch_data,
              CopyData &           copy_data) const;

  template<typename TestEvaluatorType, typename AnsatzEvaluatorType>
  void
  cell_worker_impl(const TestEvaluatorType &       phi_test,
                   const AnsatzEvaluatorType &     phi_ansatz,
                   ::MW::DoF::CopyData::CellData & cell_data) const;

  void
  face_worker(const IteratorType & cellU,
              const IteratorType & cellP,
              const unsigned int & f,
              const unsigned int & sf,
              const IteratorType & ncellU,
              const IteratorType & ncellP,
              const unsigned int & nf,
              const unsigned int & nsf,
              ScratchData<dim> &   scratch_data,
              CopyData &           copy_data) const;

  template<bool is_uniface>
  void
  boundary_or_uniface_worker(const IteratorType & cellU,
                             const IteratorType & cellP,
                             const unsigned int & f,
                             const unsigned int & sf,
                             ScratchData<dim> &   scratch_data,
                             CopyData &           copy_data) const;

  void
  uniface_worker(const IteratorType & cellU,
                 const IteratorType & cellP,
                 const unsigned int & f,
                 const unsigned int & sf,
                 ScratchData<dim> &   scratch_data,
                 CopyData &           copy_data) const;

  void
  boundary_worker(const IteratorType & cellU,
                  const IteratorType & cellP,
                  const unsigned int & f,
                  ScratchData<dim> &   scratch_data,
                  CopyData &           copy_data) const;

  const LinearAlgebra::distributed::Vector<double> * discrete_solutionU;
  const LinearAlgebra::distributed::Vector<double> * discrete_solutionP;
  const Function<dim> *                              analytical_solutionU;
  const Function<dim> *                              analytical_solutionP;
  const EquationData                                 equation_data;
};


template<int dim, bool is_multigrid>
template<typename TestEvaluatorType, typename AnsatzEvaluatorType>
void
MatrixIntegrator<dim, is_multigrid>::cell_worker_impl(
  const TestEvaluatorType &       phiU,
  const AnsatzEvaluatorType &     phiP,
  ::MW::DoF::CopyData::CellData & cell_data) const
{
  AssertDimension(phiU.n_quadrature_points, phiP.n_quadrature_points);

  for(unsigned int q = 0; q < phiU.n_quadrature_points; ++q)
  {
    for(unsigned int i = 0; i < cell_data.dof_indices.size(); ++i) // test
    {
      const auto div_phiU_i = compute_divergence(phiU, i, q);
      for(unsigned int j = 0; j < cell_data.dof_indices_column.size(); ++j) // ansatz
      {
        const auto phiP_j = phiP.shape_value(j, q);

        cell_data.matrix(i, j) += -div_phiU_i * phiP_j * phiU.JxW(q);
      }
    }
  }
}


template<int dim, bool is_multigrid>
void
MatrixIntegrator<dim, is_multigrid>::cell_worker(const IteratorType & cellU,
                                                 const IteratorType & cellP,
                                                 ScratchData<dim> &   scratch_data,
                                                 CopyData &           copy_data_pair) const
{
  auto & [copy_data, copy_data_flipped] = copy_data_pair;

  AssertDimension(copy_data.cell_data.size(), 0U);
  AssertDimension(copy_data_flipped.cell_data.size(), 0U);
  AssertDimension(cellU->index(), cellP->index());

  /// Velocity "U" takes test function role (in flipped mode ansatz function)
  auto & phiU = scratch_data.fe_values_test;
  phiU.reinit(cellU);
  const auto n_dofs_per_cellU = phiU.dofs_per_cell;

  /// Pressure "P" takes ansatz function role (in flipped mode test function)
  auto & phiP = scratch_data.fe_values_ansatz;
  phiP.reinit(cellP);
  const auto n_dofs_per_cellP = phiP.dofs_per_cell;

  auto & cell_data = copy_data.cell_data.emplace_back(n_dofs_per_cellU, n_dofs_per_cellP);
  auto & cell_data_flipped =
    copy_data_flipped.cell_data.emplace_back(n_dofs_per_cellP, n_dofs_per_cellU);

  cellU->get_active_or_mg_dof_indices(cell_data.dof_indices);
  cellP->get_active_or_mg_dof_indices(cell_data.dof_indices_column);

  cell_worker_impl(phiU, phiP, cell_data);

  /// pressure-velocity block ("flipped") is the transpose of the
  /// velocity-pressure block
  for(unsigned int i = 0; i < n_dofs_per_cellU; ++i)
    for(unsigned int j = 0; j < n_dofs_per_cellP; ++j)
      cell_data_flipped.matrix(j, i) = cell_data.matrix(i, j);

  /// Lifting of inhomogeneous boundary condition
  if(!is_multigrid)
    if(discrete_solutionU && cellU->at_boundary())
    {
      AssertDimension(n_dofs_per_cellU, cell_data.dof_indices.size());
      AssertDimension(n_dofs_per_cellP, cell_data.dof_indices_column.size());
      Vector<double> u0(n_dofs_per_cellU);
      for(auto i = 0U; i < u0.size(); ++i)
        u0(i) = (*discrete_solutionU)(cell_data.dof_indices[i]);
      Vector<double> w0(n_dofs_per_cellP);
      cell_data_flipped.matrix.vmult(w0, u0);
      AssertDimension(n_dofs_per_cellP, cell_data_flipped.rhs.size());
      cell_data_flipped.rhs -= w0;
    }
}



template<int dim, bool is_multigrid>
void
MatrixIntegrator<dim, is_multigrid>::face_worker(const IteratorType & cellU,
                                                 const IteratorType & cellP,
                                                 const unsigned int & f,
                                                 const unsigned int & sf,
                                                 const IteratorType & ncellU,
                                                 const IteratorType & ncellP,
                                                 const unsigned int & nf,
                                                 const unsigned int & nsf,
                                                 ScratchData<dim> &   scratch_data,
                                                 CopyData &           copy_data_pair) const
{
  auto & [copy_data, copy_data_flipped] = copy_data_pair;

  /// Velocity "U" takes test function role (in flipped mode ansatz function)
  auto & phiU = scratch_data.fe_interface_values_test;
  phiU.reinit(cellU, f, sf, ncellU, nf, nsf);
  const auto n_dofsU = phiU.n_current_interface_dofs();

  /// Pressure "P" takes ansatz function role (in flipped mode test function)
  auto & phiP = scratch_data.fe_interface_values_ansatz;
  phiP.reinit(cellP, f, sf, ncellP, nf, nsf);
  const auto n_dofsP = phiP.n_current_interface_dofs();

  AssertDimension(phiU.n_quadrature_points, phiP.n_quadrature_points);

  auto & face_data         = copy_data.face_data.emplace_back(n_dofsU, n_dofsP);
  auto & face_data_flipped = copy_data_flipped.face_data.emplace_back(n_dofsP, n_dofsU);

  face_data.dof_indices        = phiU.get_interface_dof_indices();
  face_data.dof_indices_column = phiP.get_interface_dof_indices();

  AssertDimension(n_dofsU, face_data.dof_indices.size());
  AssertDimension(n_dofsP, face_data.dof_indices_column.size());

  double integral_ijq = 0.;
  for(unsigned int q = 0; q < phiU.n_quadrature_points; ++q)
  {
    for(unsigned int i = 0; i < n_dofsU; ++i)
    {
      const auto & jump_phiU_i_dot_n = compute_vjump_dot_normal(phiU, i, q);

      for(unsigned int j = 0; j < n_dofsP; ++j)
      {
        const auto & av_phiP_j = phiP.average(j, q);

        integral_ijq = av_phiP_j * jump_phiU_i_dot_n * phiU.JxW(q);

        face_data.matrix(i, j) += integral_ijq;
      }
    }
  }

  /// pressure-velocity block ("flipped") is the transpose of the
  /// velocity-pressure block
  face_data_flipped.matrix.reinit(n_dofsP, n_dofsU);
  for(unsigned int i = 0; i < n_dofsU; ++i)
    for(unsigned int j = 0; j < n_dofsP; ++j)
      face_data_flipped.matrix(j, i) = face_data.matrix(i, j);
}



template<int dim, bool is_multigrid>
template<bool is_uniface>
void
MatrixIntegrator<dim, is_multigrid>::boundary_or_uniface_worker(const IteratorType & cellU,
                                                                const IteratorType & cellP,
                                                                const unsigned int & f,
                                                                const unsigned int & sf,
                                                                ScratchData<dim> &   scratch_data,
                                                                CopyData & copy_data_pair) const
{
  constexpr bool do_rhs = !is_multigrid && !is_uniface;

  if(!is_uniface)
    AssertDimension(sf, numbers::invalid_unsigned_int); // prevent from being used

  auto & [copy_data, copy_data_flipped] = copy_data_pair;

  /// Velocity "U" takes test function role (in flipped mode ansatz function)
  if(is_uniface)
    scratch_data.fe_interface_values_test.reinit(cellU, f, sf, cellU, f, sf);
  else
    scratch_data.fe_interface_values_test.reinit(cellU, f);
  const auto & phiU    = scratch_data.fe_interface_values_test.get_fe_face_values(0);
  const auto   n_dofsU = phiU.dofs_per_cell; // phiU.n_current_interface_dofs();

  /// Pressure "P" takes ansatz function role (in flipped mode test function)
  if(is_uniface)
    scratch_data.fe_interface_values_ansatz.reinit(cellP, f, sf, cellP, f, sf);
  else
    scratch_data.fe_interface_values_ansatz.reinit(cellP, f);
  const auto & phiP    = scratch_data.fe_interface_values_ansatz.get_fe_face_values(0);
  const auto   n_dofsP = phiP.dofs_per_cell;

  auto & face_data         = copy_data.face_data.emplace_back(n_dofsU, n_dofsP);
  auto & face_data_flipped = copy_data_flipped.face_data.emplace_back(n_dofsP, n_dofsU);

  cellU->get_active_or_mg_dof_indices(face_data.dof_indices);
  cellP->get_active_or_mg_dof_indices(face_data.dof_indices_column);

  const std::vector<Tensor<1, dim>> & normals = phiU.get_normal_vectors();

  AssertDimension(phiU.n_quadrature_points, phiP.n_quadrature_points);
  std::vector<double> velocity_solution_dot_normals;
  if(do_rhs)
  {
    Assert(analytical_solutionU, ExcMessage("analytical_solutionU is not set."));
    AssertDimension(analytical_solutionU->n_components, dim);
    const auto & q_points = phiU.get_quadrature_points();
    std::transform(q_points.cbegin(),
                   q_points.cend(),
                   normals.cbegin(),
                   std::back_inserter(velocity_solution_dot_normals),
                   [this](const auto & x_q, const auto & normal) {
                     Tensor<1, dim> u_q;
                     for(auto c = 0U; c < dim; ++c)
                       u_q[c] = analytical_solutionU->value(x_q, c);
                     return u_q * normal;
                   });
  }

  double integral_ijq = 0.;
  double integral_jq  = 0.;
  for(unsigned int q = 0; q < phiP.n_quadrature_points; ++q)
  {
    for(unsigned int j = 0; j < n_dofsP; ++j)
    {
      const auto & av_phiP_j = is_uniface ? 0.5 * phiP.shape_value(j, q) : phiP.shape_value(j, q);

      /// weak Dirichlet conditions (P is test function)
      if(do_rhs)
      {
        const auto & u_dot_n =
          velocity_solution_dot_normals[q]; // !!! should be zero for hdiv conf method

        integral_jq = u_dot_n * av_phiP_j * phiP.JxW(q);

        face_data_flipped.rhs(j) += integral_jq;
      }

      /// interior penalty contribution
      for(unsigned int i = 0; i < n_dofsU; ++i)
      {
        const auto & jump_phiU         = compute_vvalue(phiU, i, q);
        const auto & n                 = normals[q];
        const auto & jump_phiU_i_dot_n = jump_phiU * n;

        integral_ijq = av_phiP_j * jump_phiU_i_dot_n * phiU.JxW(q);

        face_data.matrix(i, j) += integral_ijq;
      }
    }
  }

  /// The pressure-velocity block ("flipped") is the transpose of the
  /// velocity-pressure block.
  for(unsigned int i = 0; i < n_dofsU; ++i)
    for(unsigned int j = 0; j < n_dofsP; ++j)
      face_data_flipped.matrix(j, i) = face_data.matrix(i, j);

  AssertDimension(copy_data.face_data.size(), copy_data_flipped.face_data.size());
}



template<int dim, bool is_multigrid>
void
MatrixIntegrator<dim, is_multigrid>::uniface_worker(const IteratorType & cellU,
                                                    const IteratorType & cellP,
                                                    const unsigned int & f,
                                                    const unsigned int & sf,
                                                    ScratchData<dim> &   scratch_data,
                                                    CopyData &           copy_data_pair) const
{
  boundary_or_uniface_worker<true>(cellU, cellP, f, sf, scratch_data, copy_data_pair);
}



template<int dim, bool is_multigrid>
void
MatrixIntegrator<dim, is_multigrid>::boundary_worker(const IteratorType & cellU,
                                                     const IteratorType & cellP,
                                                     const unsigned int & f,
                                                     ScratchData<dim> &   scratch_data,
                                                     CopyData &           copy_data_pair) const
{
  boundary_or_uniface_worker<false>(
    cellU, cellP, f, numbers::invalid_unsigned_int, scratch_data, copy_data_pair);

  // auto & [copy_data, copy_data_flipped] = copy_data_pair;

  // /// Velocity "U" takes test function role (in flipped mode ansatz function)
  // auto & phiU = scratch_data.fe_interface_values_test;
  // phiU.reinit(cellU, f);
  // const auto n_dofsU = phiU.n_current_interface_dofs();

  // /// Pressure "P" takes ansatz function role (in flipped mode test function)
  // auto & phiP = scratch_data.fe_interface_values_ansatz;
  // phiP.reinit(cellP, f);
  // const auto n_dofsP = phiP.n_current_interface_dofs();

  // auto & face_data         = copy_data.face_data.emplace_back(n_dofsU, n_dofsP);
  // auto & face_data_flipped = copy_data_flipped.face_data.emplace_back(n_dofsP, n_dofsU);

  // face_data.dof_indices        = phiU.get_interface_dof_indices();
  // face_data.dof_indices_column = phiP.get_interface_dof_indices();

  // AssertDimension(phiU.n_quadrature_points, phiP.n_quadrature_points);
  // std::vector<double> velocity_solution_dot_normals;
  // if(!is_multigrid)
  // {
  //   Assert(analytical_solutionU, ExcMessage("analytical_solutionU is not set."));
  //   AssertDimension(analytical_solutionU->n_components, dim);
  //   const auto &                        q_points = phiU.get_quadrature_points();
  //   const std::vector<Tensor<1, dim>> & normals  = phiU.get_normal_vectors();
  //   std::transform(q_points.cbegin(),
  //                  q_points.cend(),
  //                  normals.cbegin(),
  //                  std::back_inserter(velocity_solution_dot_normals),
  //                  [this](const auto & x_q, const auto & normal) {
  //                    Tensor<1, dim> u_q;
  //                    for(auto c = 0U; c < dim; ++c)
  //                      u_q[c] = analytical_solutionU->value(x_q, c);
  //                    return u_q * normal;
  //                  });
  // }

  // double integral_ijq = 0.;
  // double integral_jq  = 0.;
  // for(unsigned int q = 0; q < phiP.n_quadrature_points; ++q)
  // {
  //   for(unsigned int j = 0; j < n_dofsP; ++j)
  //   {
  //     const auto & av_phiP_j = phiP.average(j, q);

  //     /// Nitsche method (weak Dirichlet conditions)
  //     if(!is_multigrid) // here P is test function
  //     {
  //       const auto & u_dot_n =
  //         velocity_solution_dot_normals[q]; // !!! should be zero for hdiv conf method

  //       integral_jq = u_dot_n * av_phiP_j * phiP.JxW(q);

  //       face_data_flipped.rhs(j) += integral_jq;
  //     }

  //     for(unsigned int i = 0; i < n_dofsU; ++i)
  //     {
  //       /// IP method
  //       const auto & jump_phiU_i_dot_n = compute_vjump_dot_normal(phiU, i, q);

  //       integral_ijq = av_phiP_j * jump_phiU_i_dot_n * phiU.JxW(q);

  //       face_data.matrix(i, j) += integral_ijq;
  //     }
  //   }
  // }

  // /// The pressure-velocity block ("flipped") is the transpose of the
  // /// velocity-pressure block.
  // for(unsigned int i = 0; i < n_dofsU; ++i)
  //   for(unsigned int j = 0; j < n_dofsP; ++j)
  //     face_data_flipped.matrix(j, i) = face_data.matrix(i, j);
}

} // namespace Mixed

} // namespace MW



/**
 * This class is actual not an "integration-type" struct for local matrices. It
 * simply uses PatchTransferBlock w.r.t. the velocity-pressure block system to
 * extract the local matrices/solvers from the (global) level matrix. The level
 * matrix is passed as argument to assemble_subspace_inverses().
 *
 * Therefore, all local matrices are stored and inverted in a standard way.
 */
template<int dim,
         int fe_degree_p,
         typename Number              = double,
         TPSS::DoFLayout dof_layout_v = TPSS::DoFLayout::Q,
         int             fe_degree_v  = fe_degree_p + 1>
class MatrixIntegratorCut
{
public:
  using This = MatrixIntegratorCut<dim, fe_degree_p, Number, dof_layout_v, fe_degree_v>;

  static constexpr int n_q_points_1d = n_q_points_1d_impl(fe_degree_v, dof_layout_v);

  using value_type    = Number;
  using transfer_type = typename TPSS::PatchTransferBlock<dim, Number>;
  using matrix_type   = Tensors::BlockMatrixBasic2x2<MatrixAsTable<VectorizedArray<Number>>>;
  using operator_type = TrilinosWrappers::BlockSparseMatrix;

  void
  initialize(const EquationData & equation_data_in)
  {
    equation_data = equation_data_in;
  }

  void
  assemble_subspace_inverses(const SubdomainHandler<dim, Number> &       subdomain_handler,
                             std::vector<matrix_type> &                  local_matrices,
                             const operator_type &                       level_matrix,
                             const std::pair<unsigned int, unsigned int> subdomain_range) const
  {
    AssertDimension(subdomain_handler.get_partition_data().n_subdomains(), local_matrices.size());

    const unsigned int n_mpi_procs = Utilities::MPI::n_mpi_processes(MPI_COMM_WORLD);

    typename matrix_type::AdditionalData additional_data;
    additional_data.basic_inverse = {equation_data.local_kernel_size,
                                     equation_data.local_kernel_threshold};

    const auto   patch_transfer        = get_patch_transfer(subdomain_handler);
    const auto & patch_worker_velocity = patch_transfer->get_patch_dof_worker(0);

    FullMatrix<double> tmp_v_v;
    FullMatrix<double> tmp_p_p;
    FullMatrix<double> tmp_v_p;
    FullMatrix<double> tmp_p_v;

    FullMatrix<double> locally_relevant_level_matrix_v_v;
    FullMatrix<double> locally_relevant_level_matrix_p_p;
    FullMatrix<double> locally_relevant_level_matrix_v_p;
    FullMatrix<double> locally_relevant_level_matrix_p_v;
    if(n_mpi_procs > 1)
    {
      const auto partitioner_v = subdomain_handler.get_vector_partitioner(0);
      const auto partitioner_p = subdomain_handler.get_vector_partitioner(1);

      locally_relevant_level_matrix_v_v =
        std::move(Util::extract_locally_relevant_matrix(level_matrix.block(0, 0), partitioner_v));
      locally_relevant_level_matrix_p_p =
        std::move(Util::extract_locally_relevant_matrix(level_matrix.block(1, 1), partitioner_p));
      locally_relevant_level_matrix_v_p = std::move(Util::extract_locally_relevant_matrix(
        level_matrix.block(0, 1), partitioner_v, partitioner_p));
      locally_relevant_level_matrix_p_v = std::move(Util::extract_locally_relevant_matrix(
        level_matrix.block(1, 0), partitioner_p, partitioner_v));

      /// DEBUG
      // std::ofstream      ofs;
      // std::ostringstream oss;
      // oss << "debug.p" << mpi_rank << ".txt";
      // ofs.open(oss.str(), std::ios_base::out);
      // locally_relevant_level_matrix_v_v.print_formatted(ofs);
    }

    const auto make_local_indices_impl =
      [&](const std::vector<types::global_dof_index> &               indices,
          const std::shared_ptr<const Utilities::MPI::Partitioner> & vector_partitioner) {
        std::vector<unsigned int> local_dof_indices;
        std::transform(indices.begin(),
                       indices.end(),
                       std::back_inserter(local_dof_indices),
                       [&](const auto dof_index) {
                         return vector_partitioner->global_to_local(dof_index);
                       });
        return local_dof_indices;
      };

    for(auto patch_index = subdomain_range.first; patch_index < subdomain_range.second;
        ++patch_index)
    {
      patch_transfer->reinit(patch_index);
      const auto n_dofs          = patch_transfer->n_dofs_per_patch();
      const auto n_dofs_velocity = patch_transfer->n_dofs_per_patch(0);
      const auto n_dofs_pressure = patch_transfer->n_dofs_per_patch(1);

      matrix_type & patch_matrix = local_matrices[patch_index];

      auto & local_block_velocity = patch_matrix.get_block(0U, 0U);
      local_block_velocity.as_table().reinit(n_dofs_velocity, n_dofs_velocity);
      tmp_v_v.reinit(n_dofs_velocity, n_dofs_velocity);

      auto & local_block_pressure = patch_matrix.get_block(1U, 1U);
      local_block_pressure.as_table().reinit(n_dofs_pressure, n_dofs_pressure);
      tmp_p_p.reinit(n_dofs_pressure, n_dofs_pressure);

      auto & local_block_velocity_pressure = patch_matrix.get_block(0U, 1U);
      local_block_velocity_pressure.as_table().reinit(n_dofs_velocity, n_dofs_pressure);
      tmp_v_p.reinit(n_dofs_velocity, n_dofs_pressure);

      auto & local_block_pressure_velocity = patch_matrix.get_block(1U, 0U);
      local_block_pressure_velocity.as_table().reinit(n_dofs_pressure, n_dofs_velocity);
      tmp_p_v.reinit(n_dofs_pressure, n_dofs_velocity);

      for(auto lane = 0U; lane < patch_worker_velocity.n_lanes_filled(patch_index); ++lane)
      {
        /// Patch-wise local and global dof indices of velocity block.
        const auto & patch_transfer_velocity = patch_transfer->get_patch_transfer(0);
        const std::vector<types::global_dof_index> velocity_dof_indices_on_patch =
          std::move(patch_transfer_velocity.get_global_dof_indices(lane));

        /// Patch-wise local and global dof indices of pressure block.
        const auto & patch_transfer_pressure = patch_transfer->get_patch_transfer(1);
        const std::vector<types::global_dof_index> pressure_dof_indices_on_patch =
          std::move(patch_transfer_pressure.get_global_dof_indices(lane));

        const auto local_dof_indices_v =
          std::move(make_local_indices_impl(velocity_dof_indices_on_patch,
                                            subdomain_handler.get_vector_partitioner(0)));

        const auto local_dof_indices_p =
          std::move(make_local_indices_impl(pressure_dof_indices_on_patch,
                                            subdomain_handler.get_vector_partitioner(1)));

        /// velocity block
        if(n_mpi_procs > 1) /// parallel
        {
          AssertThrow(equation_data.local_solver == LocalSolver::Exact, ExcMessage("TODO..."));
          tmp_v_v.extract_submatrix_from(locally_relevant_level_matrix_v_v,
                                         local_dof_indices_v,
                                         local_dof_indices_v);
          local_block_velocity.fill_submatrix(tmp_v_v, 0U, 0U, lane);
        }

        else /// serial
        {
          if(equation_data.local_solver == LocalSolver::DiagonalVelocity)
          {
            for(auto comp = 0U; comp < dim; ++comp)
            {
              std::vector<types::global_dof_index> velocity_dof_indices_per_comp;
              const auto view = patch_transfer_velocity.get_dof_indices(lane, comp);
              std::copy(view.cbegin(),
                        view.cend(),
                        std::back_inserter(velocity_dof_indices_per_comp));
              const auto n_velocity_dofs_per_comp = velocity_dof_indices_per_comp.size();

              tmp_v_v.reinit(n_velocity_dofs_per_comp, n_velocity_dofs_per_comp);
              tmp_v_v.extract_submatrix_from(level_matrix.block(0U, 0U),
                                             velocity_dof_indices_per_comp,
                                             velocity_dof_indices_per_comp);

              const auto start = comp * n_velocity_dofs_per_comp;
              local_block_velocity.fill_submatrix(tmp_v_v, start, start, lane);
            }
          }
          else
          {
            tmp_v_v.extract_submatrix_from(level_matrix.block(0U, 0U),
                                           velocity_dof_indices_on_patch,
                                           velocity_dof_indices_on_patch);
            local_block_velocity.fill_submatrix(tmp_v_v, 0U, 0U, lane);
          }
        }

        /// pressure block
        if(n_mpi_procs > 1) /// parallel
          tmp_p_p.extract_submatrix_from(locally_relevant_level_matrix_p_p,
                                         local_dof_indices_p,
                                         local_dof_indices_p);
        else /// serial
          tmp_p_p.extract_submatrix_from(level_matrix.block(1U, 1U),
                                         pressure_dof_indices_on_patch,
                                         pressure_dof_indices_on_patch);
        local_block_pressure.fill_submatrix(tmp_p_p, 0U, 0U, lane);

        /// velocity-pressure block
        if(n_mpi_procs > 1) /// parallel
          tmp_v_p.extract_submatrix_from(locally_relevant_level_matrix_v_p,
                                         local_dof_indices_v,
                                         local_dof_indices_p);
        else
          tmp_v_p.extract_submatrix_from(level_matrix.block(0U, 1U),
                                         velocity_dof_indices_on_patch,
                                         pressure_dof_indices_on_patch);
        local_block_velocity_pressure.fill_submatrix(tmp_v_p, 0U, 0U, lane);

        /// pressure-velocity block
        if(n_mpi_procs > 1) /// parallel
          tmp_p_v.extract_submatrix_from(locally_relevant_level_matrix_p_v,
                                         local_dof_indices_p,
                                         local_dof_indices_v);
        else
          tmp_p_v.extract_submatrix_from(level_matrix.block(1U, 0U),
                                         pressure_dof_indices_on_patch,
                                         velocity_dof_indices_on_patch);
        local_block_pressure_velocity.fill_submatrix(tmp_p_v, 0U, 0U, lane);
      }

      (void)n_dofs;
      AssertDimension(patch_matrix.m(), n_dofs);
      AssertDimension(patch_matrix.n(), n_dofs);

      patch_matrix.invert(additional_data);
    }
  }

  std::shared_ptr<transfer_type>
  get_patch_transfer(const SubdomainHandler<dim, Number> & subdomain_handler) const
  {
    std::vector<const TPSS::DoFInfo<dim, Number> *> dofinfos;
    dofinfos.push_back(&subdomain_handler.get_dof_info(0));
    dofinfos.push_back(&subdomain_handler.get_dof_info(1));
    return std::make_shared<transfer_type>(dofinfos);
  }

  EquationData       equation_data;
  const unsigned int mpi_rank = Utilities::MPI::this_mpi_process(MPI_COMM_WORLD);
};



namespace FD
{
/**
 * Assembles the (exact) local matrices/solvers by exploiting the tensor
 * structure of each scalar-valued shape function, that is each block of a
 * patch matrix involving a component of the velocity vector-field and/or a
 * pressure function have a low-rank Kronecker product decomposition (representation?).
 *
 * However, each block matrix itself has no low-rank Kronecker decomposition
 * (representation?), thus, local matrices are stored and inverted in a
 * standard (vectorized) fashion.
 */
template<int dim,
         int fe_degree_p,
         typename Number              = double,
         TPSS::DoFLayout dof_layout_v = TPSS::DoFLayout::Q,
         int             fe_degree_v  = fe_degree_p + 1>
class MatrixIntegrator
{
public:
  using This = MatrixIntegrator<dim, fe_degree_p, Number>;

  static constexpr int n_q_points_1d = n_q_points_1d_impl(fe_degree_v, dof_layout_v);

  using value_type              = Number;
  using transfer_type           = typename TPSS::PatchTransferBlock<dim, Number>;
  using matrix_type_1d          = Table<2, VectorizedArray<Number>>;
  using matrix_type             = MatrixAsTable<VectorizedArray<Number>>;
  using matrix_type_mixed       = Tensors::BlockMatrix<dim, VectorizedArray<Number>, -1, -1>;
  using velocity_evaluator_type = FDEvaluation<dim, fe_degree_v, n_q_points_1d, Number>;
  using pressure_evaluator_type = FDEvaluation<dim, fe_degree_p, n_q_points_1d, Number>;

  void
  initialize(const EquationData & equation_data_in)
  {
    equation_data = equation_data_in;
  }

  template<typename OperatorType>
  void
  assemble_subspace_inverses(const SubdomainHandler<dim, Number> &       subdomain_handler,
                             std::vector<matrix_type> &                  local_matrices,
                             const OperatorType &                        dummy_operator,
                             const std::pair<unsigned int, unsigned int> subdomain_range) const
  {
    AssertDimension(subdomain_handler.get_partition_data().n_subdomains(), local_matrices.size());

    using MatrixIntegratorVelocity =
      Velocity::SIPG::FD::MatrixIntegrator<dim, fe_degree_v, Number, dof_layout_v>;
    static_assert(std::is_same<typename MatrixIntegratorVelocity::evaluator_type,
                               velocity_evaluator_type>::value,
                  "Velocity evaluator types mismatch.");
    using matrix_type_velocity = typename MatrixIntegratorVelocity::matrix_type;

    /// Assemble local matrices for the local velocity-velocity block.
    std::vector<matrix_type_velocity> local_matrices_velocity(local_matrices.size());
    {
      MatrixIntegratorVelocity matrix_integrator;
      matrix_integrator.initialize(equation_data);

      matrix_integrator.template assemble_subspace_inverses<OperatorType>(subdomain_handler,
                                                                          local_matrices_velocity,
                                                                          dummy_operator,
                                                                          subdomain_range);
    }

    /// Assemble local matrices for the local pressure-pressure block
    {
      /// This block is zero.
    }

    /// Assemble local matrices for the local velocity-pressure block
    std::vector<matrix_type_mixed> local_matrices_velocity_pressure(local_matrices.size());
    {
      assemble_mixed_subspace_inverses<OperatorType>(subdomain_handler,
                                                     local_matrices_velocity_pressure,
                                                     dummy_operator,
                                                     subdomain_range);
    }

    AssertDimension(local_matrices_velocity.size(), local_matrices.size());
    const auto patch_transfer = get_patch_transfer(subdomain_handler);
    for(auto patch_index = subdomain_range.first; patch_index < subdomain_range.second;
        ++patch_index)
    {
      const auto & local_block_velocity          = local_matrices_velocity[patch_index];
      const auto & local_block_velocity_pressure = local_matrices_velocity_pressure[patch_index];

      patch_transfer->reinit(patch_index);
      const auto n_dofs          = patch_transfer->n_dofs_per_patch();
      const auto n_dofs_velocity = local_block_velocity.m();
      const auto n_dofs_pressure = local_block_velocity_pressure.n();
      AssertDimension(patch_transfer->n_dofs_per_patch(0), n_dofs_velocity);
      (void)n_dofs_pressure;
      AssertDimension(patch_transfer->n_dofs_per_patch(1), n_dofs_pressure);

      auto & local_matrix = local_matrices[patch_index];
      local_matrix.as_table().reinit(n_dofs, n_dofs);

      /// velocity-velocity
      local_matrix.fill_submatrix(local_block_velocity.as_table(), 0U, 0U);

      /// velocity-pressure
      local_matrix.fill_submatrix(local_block_velocity_pressure.as_table(), 0U, n_dofs_velocity);

      /// pressure-velocity
      local_matrix.template fill_submatrix<true>(local_block_velocity_pressure.as_table(),
                                                 n_dofs_velocity,
                                                 0U);

      local_matrix.invert({equation_data.local_kernel_size, equation_data.local_kernel_threshold});
    }
  }

  template<typename OperatorType>
  void
  assemble_mixed_subspace_inverses(
    const SubdomainHandler<dim, Number> & subdomain_handler,
    std::vector<matrix_type_mixed> &      local_matrices,
    const OperatorType &,
    const std::pair<unsigned int, unsigned int> subdomain_range) const
  {
    AssertDimension(subdomain_handler.get_partition_data().n_subdomains(), local_matrices.size());

    for(auto compU = 0U; compU < dim; ++compU)
    {
      velocity_evaluator_type eval_velocity(subdomain_handler, /*dofh_index*/ 0, compU);
      pressure_evaluator_type eval_pressure(subdomain_handler, /*dofh_index*/ 1, /*component*/ 0);

      for(unsigned int patch = subdomain_range.first; patch < subdomain_range.second; ++patch)
      {
        auto & velocity_pressure_matrix = local_matrices[patch];
        if(velocity_pressure_matrix.n_block_rows() == 0 &&
           velocity_pressure_matrix.n_block_cols() == 0)
          velocity_pressure_matrix.resize(dim, 1);

        eval_velocity.reinit(patch);
        eval_pressure.reinit(patch);

        const auto mass_matrices =
          assemble_mass_tensor(/*test*/ eval_velocity, /*ansatz*/ eval_pressure);
        /// Note that we have flipped ansatz and test functions roles. The
        /// divergence of the velocity test functions is obtained by
        /// transposing gradient matrices.
        const auto gradient_matrices =
          assemble_gradient_tensor(/*test*/ eval_pressure, /*ansatz*/ eval_velocity);

        const auto & MxMxGT = [&](const unsigned int direction_of_div) {
          /// For example, we obtain MxMxGT for direction_of_div = 0 (dimension
          /// 0 is rightmost!)
          std::array<matrix_type_1d, dim> kronecker_tensor;
          for(auto d = 0U; d < dim; ++d)
            kronecker_tensor[d] = d == direction_of_div ?
                                    -1. * LinAlg::transpose(gradient_matrices[direction_of_div]) :
                                    mass_matrices[d];
          return kronecker_tensor;
        };

        std::vector<std::array<matrix_type_1d, dim>> rank1_tensors;
        rank1_tensors.emplace_back(MxMxGT(compU));
        velocity_pressure_matrix.get_block(compU, 0).reinit(rank1_tensors);
      }
    }
  }

  std::array<matrix_type_1d, dim>
  assemble_mass_tensor(velocity_evaluator_type & eval_test,
                       pressure_evaluator_type & eval_ansatz) const
  {
    using CellMass = ::FD::L2::CellOperation<dim, fe_degree_v, n_q_points_1d, Number, fe_degree_p>;
    return eval_test.patch_action(eval_ansatz, CellMass{});
  }

  /**
   * We remark that the velocity takes the ansatz function role here
   * (Gradient::CellOperation derives the ansatz function) although in
   * assemble_mixed_subspace_inverses() we require the divergence of the
   * velocity test functions. Therefore, we transpose the returned tensor of
   * matrices.
   */
  std::array<matrix_type_1d, dim>
  assemble_gradient_tensor(pressure_evaluator_type & eval_test,
                           velocity_evaluator_type & eval_ansatz) const
  {
    using CellGradient =
      ::FD::Gradient::CellOperation<dim, fe_degree_p, n_q_points_1d, Number, fe_degree_v>;
    CellGradient cell_gradient;
    return eval_test.patch_action(eval_ansatz, cell_gradient);
  }

  std::shared_ptr<transfer_type>
  get_patch_transfer(const SubdomainHandler<dim, Number> & subdomain_handler) const
  {
    std::vector<const TPSS::DoFInfo<dim, Number> *> dofinfos;
    dofinfos.push_back(&subdomain_handler.get_dof_info(0));
    dofinfos.push_back(&subdomain_handler.get_dof_info(1));
    return std::make_shared<transfer_type>(dofinfos);
  }

  EquationData equation_data;
};

} // namespace FD



namespace LMW
{
/**
 * This class actually makes no use of fast diagonalization but simply uses the
 * MeshWorker framework to assemble local matrices. Nevertheless
 * PatchTransferBlock is used as transfer and its underlying PatchDoFWorker to
 * determine collections of cell iterators.
 *
 * Therefore, all local matrices are stored and inverted in a standard way, that
 * is without exploiting any tensor structure.
 */
template<int dim,
         int fe_degree_p,
         typename Number               = double,
         TPSS::DoFLayout dof_layout_v  = TPSS::DoFLayout::Q,
         int             fe_degree_v   = fe_degree_p + 1,
         bool            is_simplified = false>
class MatrixIntegrator
{
public:
  using This = MatrixIntegrator<dim, fe_degree_p, Number, dof_layout_v, fe_degree_v, is_simplified>;

  static constexpr int n_q_points_1d = n_q_points_1d_impl(fe_degree_v, dof_layout_v);

  static constexpr bool use_sipg_method     = dof_layout_v == TPSS::DoFLayout::DGQ;
  static constexpr bool use_hdivsipg_method = dof_layout_v == TPSS::DoFLayout::RT;
  static constexpr bool use_conf_method     = dof_layout_v == TPSS::DoFLayout::Q;

  using value_type    = Number;
  using transfer_type = typename TPSS::PatchTransferBlock<dim, Number>;
  using matrix_type   = Tensors::BlockMatrixBasic2x2<MatrixAsTable<VectorizedArray<Number>>>;
  using operator_type = TrilinosWrappers::BlockSparseMatrix;

  void
  initialize(const EquationData & equation_data_in)
  {
    equation_data = equation_data_in;
  }

  void
  assemble_subspace_inverses(const SubdomainHandler<dim, Number> & subdomain_handler,
                             std::vector<matrix_type> &            local_matrices,
                             const operator_type & /*level_matrix*/,
                             const std::pair<unsigned int, unsigned int> subdomain_range) const
  {
    AssertDimension(subdomain_handler.get_partition_data().n_subdomains(), local_matrices.size());

    typename matrix_type::AdditionalData additional_data;
    additional_data.basic_inverse = {equation_data.local_kernel_size,
                                     equation_data.local_kernel_threshold};

    const auto   patch_transfer     = get_patch_transfer(subdomain_handler);
    const auto & patch_dof_worker_v = patch_transfer->get_patch_dof_worker(0);
    const auto & patch_dof_worker_p = patch_transfer->get_patch_dof_worker(1);

    FullMatrix<double> tmp_v_v;
    FullMatrix<double> tmp_p_p;
    FullMatrix<double> tmp_v_p;
    FullMatrix<double> tmp_p_v;

    const auto [begin, end] = subdomain_range;
    for(auto patch_index = begin; patch_index < end; ++patch_index)
    {
      patch_transfer->reinit(patch_index);

      const auto n_dofs          = patch_transfer->n_dofs_per_patch();
      const auto n_dofs_velocity = patch_transfer->n_dofs_per_patch(0);
      const auto n_dofs_pressure = patch_transfer->n_dofs_per_patch(1);

      const auto & patch_transfer_v = patch_transfer->get_patch_transfer(0);
      const auto & patch_transfer_p = patch_transfer->get_patch_transfer(1);

      matrix_type & patch_matrix = local_matrices[patch_index];

      auto & block_velocity = patch_matrix.get_block(0U, 0U);
      block_velocity.as_table().reinit(n_dofs_velocity, n_dofs_velocity);
      tmp_v_v.reinit(n_dofs_velocity, n_dofs_velocity);

      auto & block_pressure = patch_matrix.get_block(1U, 1U);
      block_pressure.as_table().reinit(n_dofs_pressure, n_dofs_pressure);
      tmp_p_p.reinit(n_dofs_pressure, n_dofs_pressure);

      auto & block_velocity_pressure = patch_matrix.get_block(0U, 1U);
      block_velocity_pressure.as_table().reinit(n_dofs_velocity, n_dofs_pressure);
      tmp_v_p.reinit(n_dofs_velocity, n_dofs_pressure);

      auto & block_pressure_velocity = patch_matrix.get_block(1U, 0U);
      block_pressure_velocity.as_table().reinit(n_dofs_pressure, n_dofs_velocity);
      tmp_p_v.reinit(n_dofs_pressure, n_dofs_velocity);

      for(auto lane = 0U; lane < patch_dof_worker_v.n_lanes_filled(patch_index); ++lane)
      {
        /// velocity block
        {
          using Velocity::SIPG::MW::CopyData;

          using Velocity::SIPG::MW::ScratchData;

          using MatrixIntegrator = Velocity::SIPG::MW::MatrixIntegrator<dim, true, is_simplified>;

          using cell_iterator_type = typename MatrixIntegrator::IteratorType;

          tmp_v_v = 0.;

          const auto & cell_collection = patch_dof_worker_v.get_cell_collection(patch_index, lane);

          const TPSS::BelongsToCollection<cell_iterator_type> belongs_to_collection(
            cell_collection);

          const auto & local_cell_range = TPSS::make_local_cell_range(cell_collection);

          const auto & g2l = patch_transfer_v.get_global_to_local_dof_indices(lane);

          const auto distribute_local_to_patch_impl = [&](const auto & cd) {
            std::vector<unsigned int> local_dof_indices;
            std::transform(cd.dof_indices.begin(),
                           cd.dof_indices.end(),
                           std::back_inserter(local_dof_indices),
                           [&](const auto dof_index) {
                             const auto & local_index = g2l.find(dof_index);
                             return local_index != g2l.cend() ? local_index->second :
                                                                numbers::invalid_unsigned_int;
                           });
            for(auto i = 0U; i < cd.matrix.m(); ++i)
              if(local_dof_indices[i] != numbers::invalid_unsigned_int)
                for(auto j = 0U; j < cd.matrix.n(); ++j)
                  if(local_dof_indices[j] != numbers::invalid_unsigned_int)
                    tmp_v_v(local_dof_indices[i], local_dof_indices[j]) += cd.matrix(i, j);
          };

          const auto local_copier = [&](const CopyData & copy_data) {
            for(const auto & cd : copy_data.cell_data)
              distribute_local_to_patch_impl(cd);
            for(const auto & cdf : copy_data.face_data)
              distribute_local_to_patch_impl(cdf);
          };

          const MatrixIntegrator matrix_integrator(nullptr, nullptr, nullptr, equation_data);

          const UpdateFlags update_flags =
            update_values | update_gradients | update_quadrature_points | update_JxW_values;
          const UpdateFlags interface_update_flags = update_flags | update_normal_vectors;
          ScratchData<dim>  scratch_data(subdomain_handler.get_mapping(),
                                        subdomain_handler.get_dof_handler(0).get_fe(),
                                        subdomain_handler.get_dof_handler(0).get_fe(),
                                        n_q_points_1d,
                                        update_flags,
                                        update_flags,
                                        interface_update_flags,
                                        interface_update_flags);

          CopyData copy_data;

          if(use_conf_method)
            MeshWorker::m2d2::mesh_loop(
              local_cell_range,
              [&](const auto & cell, auto & scratch_data, auto & copy_data) {
                matrix_integrator.cell_worker(cell, scratch_data, copy_data);
              },
              local_copier,
              scratch_data,
              copy_data,
              MeshWorker::assemble_own_cells | MeshWorker::assemble_ghost_cells);

          else if(use_sipg_method || use_hdivsipg_method)
            MeshWorker::m2d2::mesh_loop(
              local_cell_range,
              [&](const auto & cell, auto & scratch_data, auto & copy_data) {
                matrix_integrator.cell_worker(cell, scratch_data, copy_data);
              },
              local_copier,
              scratch_data,
              copy_data,
              MeshWorker::assemble_own_cells | MeshWorker::assemble_ghost_cells |
                MeshWorker::assemble_boundary_faces | MeshWorker::assemble_own_interior_faces_both |
                MeshWorker::assemble_ghost_faces_both,
              /*assemble faces at ghosts?*/ true,
              [&](const auto & cell, const auto face_no, auto & scratch_data, auto & copy_data) {
                if(use_sipg_method)
                  matrix_integrator.boundary_worker(cell, face_no, scratch_data, copy_data);
                else if(use_hdivsipg_method)
                  matrix_integrator.boundary_worker_tangential(cell,
                                                               face_no,
                                                               scratch_data,
                                                               copy_data);
              },
              [&](const auto & cell,
                  const auto   face_no,
                  const auto   sface_no,
                  const auto & ncell,
                  const auto   nface_no,
                  const auto   nsface_no,
                  auto &       scratch_data,
                  auto &       copy_data) {
                const bool cell_belongs_to_collection  = belongs_to_collection(cell);
                const bool ncell_belongs_to_collection = belongs_to_collection(ncell);
                const bool is_interface = cell_belongs_to_collection && ncell_belongs_to_collection;
                if(is_interface)
                {
                  if(use_sipg_method)
                    matrix_integrator.face_worker(
                      cell, face_no, sface_no, ncell, nface_no, nsface_no, scratch_data, copy_data);
                  else if(use_hdivsipg_method)
                    matrix_integrator.face_worker_tangential(
                      cell, face_no, sface_no, ncell, nface_no, nsface_no, scratch_data, copy_data);
                  copy_data.face_data.back().matrix *= 0.5; /// both sides!
                  return;
                }
                if(cell_belongs_to_collection)
                {
                  if(use_sipg_method)
                    matrix_integrator.uniface_worker(
                      cell, face_no, sface_no, scratch_data, copy_data);
                  else if(use_hdivsipg_method)
                    matrix_integrator.uniface_worker_tangential(
                      cell, face_no, sface_no, scratch_data, copy_data);
                }
              });

          else
            Assert(false, ExcMessage("FEM is not implemented."));
        }

        if(equation_data.local_solver == LocalSolver::DiagonalVelocity)
        {
          for(auto comp = 0U; comp < dim; ++comp)
          {
            const std::vector<types::global_dof_index> & velocity_dof_indices_per_comp =
              patch_transfer_v.get_global_dof_indices(lane, comp);
            const auto n_velocity_dofs_per_comp = velocity_dof_indices_per_comp.size();

            const unsigned int start = comp * n_velocity_dofs_per_comp;

            std::vector<unsigned int> local_dof_indices(n_velocity_dofs_per_comp);
            std::iota(local_dof_indices.begin(), local_dof_indices.end(), start);

            FullMatrix<double> tmp_per_comp(n_velocity_dofs_per_comp);
            tmp_per_comp.extract_submatrix_from(tmp_v_v, local_dof_indices, local_dof_indices);

            block_velocity.fill_submatrix(tmp_per_comp, start, start, lane);
          }
        }
        else if(equation_data.local_solver == LocalSolver::Exact)
          block_velocity.fill_submatrix(tmp_v_v, 0U, 0U, lane);
        else
          Assert(false, ExcMessage("local solver variant not implemented"));

        /// pressure block (just fill with zeros!)
        block_pressure.fill_submatrix(tmp_p_p, 0U, 0U, lane);

        /// velocity-pressure block & pressure-velocity block
        {
          using VelocityPressure::MW::Mixed::CopyData;

          using VelocityPressure::MW::Mixed::ScratchData;

          using MatrixIntegrator = VelocityPressure::MW::Mixed::MatrixIntegrator<dim, true>; // ???

          using cell_iterator_type = typename MatrixIntegrator::IteratorType;

          tmp_v_p = 0.;
          tmp_p_v = 0.;

          const auto & dof_handler_velocity = subdomain_handler.get_dof_handler(0);
          const auto & dof_handler_pressure = subdomain_handler.get_dof_handler(1);

          const auto & cell_collection_v =
            patch_dof_worker_v.get_cell_collection(patch_index, lane);
          const auto & cell_collection_p =
            patch_dof_worker_p.get_cell_collection(patch_index, lane);

          const auto & local_cell_range_v = TPSS::make_local_cell_range(cell_collection_v);

          const TPSS::BelongsToCollection<cell_iterator_type> belongs_to_collection_v(
            cell_collection_v);

          const auto & g2l_v = patch_transfer_v.get_global_to_local_dof_indices(lane);
          const auto & g2l_p = patch_transfer_p.get_global_to_local_dof_indices(lane);

          const auto distribute_local_to_patch_impl = [&](const auto & cd,
                                                          const auto & cd_flipped) {
            std::vector<unsigned int> local_dof_indices_v;
            std::transform(cd.dof_indices.begin(),
                           cd.dof_indices.end(),
                           std::back_inserter(local_dof_indices_v),
                           [&](const auto dof_index) {
                             const auto & local_index = g2l_v.find(dof_index);
                             return local_index != g2l_v.cend() ? local_index->second :
                                                                  numbers::invalid_unsigned_int;
                           });
            std::vector<unsigned int> local_dof_indices_p;
            std::transform(cd.dof_indices_column.begin(),
                           cd.dof_indices_column.end(),
                           std::back_inserter(local_dof_indices_p),
                           [&](const auto dof_index) {
                             const auto & local_index = g2l_p.find(dof_index);
                             return local_index != g2l_p.cend() ? local_index->second :
                                                                  numbers::invalid_unsigned_int;
                           });
            AssertDimension(cd.matrix.m(), local_dof_indices_v.size());
            AssertDimension(cd.matrix.n(), local_dof_indices_p.size());
            /// velocity-pressure
            for(auto i = 0U; i < cd.matrix.m(); ++i)
              if(local_dof_indices_v[i] != numbers::invalid_unsigned_int)
                for(auto j = 0U; j < cd.matrix.n(); ++j)
                  if(local_dof_indices_p[j] != numbers::invalid_unsigned_int)
                    tmp_v_p(local_dof_indices_v[i], local_dof_indices_p[j]) += cd.matrix(i, j);
            AssertDimension(cd_flipped.matrix.m(), local_dof_indices_p.size());
            AssertDimension(cd_flipped.matrix.n(), local_dof_indices_v.size());
            /// pressure-velocity
            for(auto i = 0U; i < cd_flipped.matrix.m(); ++i)
              if(local_dof_indices_p[i] != numbers::invalid_unsigned_int)
                for(auto j = 0U; j < cd_flipped.matrix.n(); ++j)
                  if(local_dof_indices_v[j] != numbers::invalid_unsigned_int)
                    tmp_p_v(local_dof_indices_p[i], local_dof_indices_v[j]) +=
                      cd_flipped.matrix(i, j);
          };

          const auto local_copier = [&](const CopyData & copy_data_pair) {
            const auto & [copy_data, copy_data_flipped] = copy_data_pair;

            AssertDimension(copy_data.cell_data.size(), copy_data_flipped.cell_data.size());
            AssertDimension(copy_data.face_data.size(), copy_data_flipped.face_data.size());

            auto cd_flipped = copy_data_flipped.cell_data.cbegin();
            auto cd         = copy_data.cell_data.cbegin();
            for(; cd != copy_data.cell_data.cend(); ++cd, ++cd_flipped)
              distribute_local_to_patch_impl(*cd, *cd_flipped);

            auto cdf_flipped = copy_data_flipped.face_data.cbegin();
            auto cdf         = copy_data.face_data.cbegin();
            for(; cdf != copy_data.face_data.cend(); ++cdf, ++cdf_flipped)
              distribute_local_to_patch_impl(*cdf, *cdf_flipped);
          };

          const MatrixIntegrator matrix_integrator(
            nullptr, nullptr, nullptr, nullptr, equation_data);

          const UpdateFlags update_flags_velocity =
            update_values | update_gradients | update_quadrature_points | update_JxW_values;
          const UpdateFlags update_flags_pressure =
            update_values | update_gradients | update_quadrature_points | update_JxW_values;
          const UpdateFlags interface_update_flags_velocity =
            update_values | update_quadrature_points | update_JxW_values | update_normal_vectors;
          const UpdateFlags interface_update_flags_pressure =
            update_values | update_quadrature_points | update_JxW_values | update_normal_vectors;

          ScratchData<dim> scratch_data(subdomain_handler.get_mapping(),
                                        dof_handler_velocity.get_fe(),
                                        dof_handler_pressure.get_fe(),
                                        n_q_points_1d,
                                        update_flags_velocity,
                                        update_flags_pressure,
                                        interface_update_flags_velocity,
                                        interface_update_flags_pressure);

          CopyData copy_data;

          const auto & cell_worker =
            [&](const cell_iterator_type & cell, auto & scratch_data, auto & copy_data) {
              cell_iterator_type cell_ansatz(&(dof_handler_pressure.get_triangulation()),
                                             cell->level(),
                                             cell->index(),
                                             &dof_handler_pressure);
              matrix_integrator.cell_worker(cell, cell_ansatz, scratch_data, copy_data);
            };

          if(use_conf_method || use_hdivsipg_method)
            MeshWorker::m2d2::mesh_loop(local_cell_range_v,
                                        cell_worker,
                                        local_copier,
                                        scratch_data,
                                        copy_data,
                                        MeshWorker::assemble_own_cells |
                                          MeshWorker::assemble_ghost_cells);

          else if(use_sipg_method)
            MeshWorker::m2d2::mesh_loop(
              local_cell_range_v,
              cell_worker,
              local_copier,
              scratch_data,
              copy_data,
              MeshWorker::assemble_own_cells | MeshWorker::assemble_ghost_cells |
                MeshWorker::assemble_boundary_faces | MeshWorker::assemble_own_interior_faces_both |
                MeshWorker::assemble_ghost_faces_both,
              /*assemble faces at ghosts?*/ true,
              [&](const auto & cell, const auto face_no, auto & scratch_data, auto & copy_data) {
                cell_iterator_type cell_ansatz(&(dof_handler_pressure.get_triangulation()),
                                               cell->level(),
                                               cell->index(),
                                               &dof_handler_pressure);
                matrix_integrator.boundary_worker(
                  cell, cell_ansatz, face_no, scratch_data, copy_data);
              },
              [&](const auto & cell,
                  const auto   face_no,
                  const auto   sface_no,
                  const auto & ncell,
                  const auto   nface_no,
                  const auto   nsface_no,
                  auto &       scratch_data,
                  auto &       copy_data_pair) {
                cell_iterator_type cell_ansatz(&(dof_handler_pressure.get_triangulation()),
                                               cell->level(),
                                               cell->index(),
                                               &dof_handler_pressure);
                cell_iterator_type ncell_ansatz(&(dof_handler_pressure.get_triangulation()),
                                                ncell->level(),
                                                ncell->index(),
                                                &dof_handler_pressure);
                const bool         cell_belongs_to_collection  = belongs_to_collection_v(cell);
                const bool         ncell_belongs_to_collection = belongs_to_collection_v(ncell);
                const bool is_interface = cell_belongs_to_collection && ncell_belongs_to_collection;
                if(is_interface)
                {
                  matrix_integrator.face_worker(cell,
                                                cell_ansatz,
                                                face_no,
                                                sface_no,
                                                ncell,
                                                ncell_ansatz,
                                                nface_no,
                                                nsface_no,
                                                scratch_data,
                                                copy_data_pair);
                  /// interfaces are assembled from both sides
                  auto & [copy_data, copy_data_flipped] = copy_data_pair;
                  copy_data.face_data.back().matrix *= 0.5;
                  copy_data_flipped.face_data.back().matrix *= 0.5;
                  return;
                }
                if(cell_belongs_to_collection)
                {
                  matrix_integrator.uniface_worker(
                    cell, cell_ansatz, face_no, sface_no, scratch_data, copy_data_pair);
                }
              });

          else
            Assert(false, ExcMessage("FEM is not implemented."));

          block_velocity_pressure.fill_submatrix(tmp_v_p, 0U, 0U, lane);

          block_pressure_velocity.fill_submatrix(tmp_p_v, 0U, 0U, lane);
        }
      }

      (void)n_dofs;
      AssertDimension(patch_matrix.m(), n_dofs);
      AssertDimension(patch_matrix.n(), n_dofs);

      patch_matrix.invert(additional_data);
    }
  }

  std::shared_ptr<transfer_type>
  get_patch_transfer(const SubdomainHandler<dim, Number> & subdomain_handler) const
  {
    std::vector<const TPSS::DoFInfo<dim, Number> *> dofinfos;
    dofinfos.push_back(&subdomain_handler.get_dof_info(0));
    dofinfos.push_back(&subdomain_handler.get_dof_info(1));
    return std::make_shared<transfer_type>(dofinfos);
  }

  EquationData equation_data;
};



template<int dim, typename Number, bool is_simplified>
struct LocalSolverStream
{
  using matrix_type          = MatrixAsTable<VectorizedArray<Number>>;
  using value_type           = typename matrix_type::value_type;
  using transfer_type        = typename TPSS::PatchTransferBlock<dim, Number>;
  using transfer_type_stream = TPSS::PatchTransfer<dim, Number>;

  const SubdomainHandler<dim, Number> * subdomain_handler = nullptr;
  unsigned int                          patch_index       = numbers::invalid_unsigned_int;
  unsigned int                          n_q_points_1d     = numbers::invalid_unsigned_int;
  const EquationData *                  equation_data;

  matrix_type                                            solver_sf;
  std::shared_ptr<const ProlongationStream<dim, Number>> prolongation_sf;

  std::shared_ptr<const FullMatrix<Number>> trafomatrix_orth;
  std::shared_ptr<const FullMatrix<Number>> trafomatrix_orth_faces;

  void
  apply_inverse(const ArrayView<value_type> &       dst_view,
                const ArrayView<const value_type> & src_view) const
  {
    std::ofstream ofs;

    Assert(subdomain_handler, ExcMessage("subdomain_handler not initialized."));

    std::fill(dst_view.begin(), dst_view.end(), 0.);

    const auto & dofh_v  = subdomain_handler->get_dof_handler(0);
    const auto & dofh_p  = subdomain_handler->get_dof_handler(1);
    const auto & dofh_sf = subdomain_handler->get_dof_handler(2);

    const auto & mapping = subdomain_handler->get_mapping();

    const auto patch_transfer    = get_patch_transfer(*subdomain_handler);
    const auto patch_transfer_sf = get_patch_transfer_stream(*subdomain_handler);

    patch_transfer->reinit(patch_index);
    patch_transfer_sf->reinit(patch_index);

    AssertDimension(src_view.size(), patch_transfer->n_dofs_per_patch());
    AssertDimension(dst_view.size(), patch_transfer->n_dofs_per_patch());

    const auto n_dofs_v  = patch_transfer->n_dofs_per_patch(0);
    const auto n_dofs_p  = patch_transfer->n_dofs_per_patch(1);
    const auto n_dofs_sf = patch_transfer_sf->n_dofs_per_patch();

    const ArrayView<value_type> dst_v_view(dst_view.begin(), n_dofs_v);
    const ArrayView<value_type> dst_p_view(dst_view.begin() + n_dofs_v, n_dofs_p);

    const ArrayView<const value_type> src_v_view(src_view.begin(), n_dofs_v);
    const ArrayView<const value_type> src_p_view(src_view.begin() + n_dofs_v, n_dofs_p);

    AlignedVector<value_type>   solution_sf(n_dofs_sf);
    const ArrayView<value_type> solution_sf_view(solution_sf.begin(), n_dofs_sf);

    AlignedVector<value_type>   rhs_sf(n_dofs_sf);
    const ArrayView<value_type> rhs_sf_view(rhs_sf.begin(), n_dofs_sf);

    prolongation_sf->dual_restrict(rhs_sf_view, src_v_view);

    solver_sf.apply_inverse(solution_sf_view, rhs_sf_view);

    prolongation_sf->prolongate(dst_v_view, solution_sf_view);

    /// solve pressure
    {
      const auto & patch_dof_worker_v = patch_transfer->get_patch_dof_worker(0);
      const auto & patch_dof_worker_p = patch_transfer->get_patch_dof_worker(1);

      for(auto lane = 0U; lane < patch_dof_worker_v.n_lanes_filled(patch_index); ++lane)
      {
        const auto & cells = patch_dof_worker_v.get_cell_collection(patch_index, lane);

        LocalInterfaceHandler<dim> interface_handler;
        interface_handler.reinit(cells);

        using CellIterator = typename DoFHandler<dim>::level_cell_iterator;

        std::vector<types::global_dof_index> constant_pressure_dof_indices(cells.size());

        const TPSS::BelongsToCollection<CellIterator> belongs_to_collection(cells);

        const auto & local_cell_range_v = TPSS::make_local_cell_range(cells);

        const auto & g2l_v =
          patch_transfer->get_patch_transfer(0).get_global_to_local_dof_indices(lane);

        const auto & g2l_p =
          patch_transfer->get_patch_transfer(1).get_global_to_local_dof_indices(lane);

        const auto & g2l_sf = patch_transfer_sf->get_global_to_local_dof_indices(lane);

        /// non-constant pressure modes
        {
          using Stokes::Velocity::SIPG::MW::ScratchData;

          using Stokes::Velocity::SIPG::MW::CopyData;

          using Stokes::Velocity::SIPG::MW::MatrixIntegrator;

          MatrixIntegrator<dim, true, is_simplified> matrix_integrator(
            nullptr, nullptr, nullptr, *equation_data, &interface_handler);

          AffineConstraints<double> empty_constraints;
          empty_constraints.close();

          const auto distribute_local_to_patch_impl = [&](const auto & cd) {
            std::vector<unsigned int> local_dof_indices_sf;
            std::transform(cd.dof_indices_column.begin(),
                           cd.dof_indices_column.end(),
                           std::back_inserter(local_dof_indices_sf),
                           [&](const auto dof_index) {
                             const auto & local_index = g2l_sf.find(dof_index);
                             return local_index != g2l_sf.cend() ? local_index->second :
                                                                   numbers::invalid_unsigned_int;
                           });

            std::vector<unsigned int> local_dof_indices_p;
            std::transform(cd.dof_indices.begin(),
                           cd.dof_indices.end(),
                           std::back_inserter(local_dof_indices_p),
                           [&](const auto dof_index) {
                             const auto & local_index = g2l_p.find(dof_index);
                             return local_index != g2l_p.cend() ? local_index->second :
                                                                  numbers::invalid_unsigned_int;
                           });

            AssertDimension(local_dof_indices_sf.size(), cd.matrix.n());
            Vector<Number> local_solution_sf(cd.matrix.n());
            for(auto i = 0U; i < local_solution_sf.size(); ++i)
              if(local_dof_indices_sf[i] != numbers::invalid_unsigned_int)
                local_solution_sf(i) = solution_sf[local_dof_indices_sf[i]][lane];

            Vector<Number> Ax(cd.matrix.m());
            cd.matrix.vmult(Ax, local_solution_sf);

            Ax -= cd.rhs; // Ax - f

            AssertDimension(local_dof_indices_p.size(), cd.matrix.m());
            for(auto i = 0U; i < Ax.size(); ++i)
            {
              Assert(local_dof_indices_p[i] != numbers::invalid_unsigned_int, ExcInternalError());
              dst_p_view[local_dof_indices_p[i]][lane] -= Ax(i); // f - Ax
            }
          };

          const auto local_copier = [&](const CopyData & copy_data) {
            for(const auto & cd : copy_data.cell_data)
            {
              distribute_local_to_patch_impl(cd);
            }
            for(const auto & cdf : copy_data.face_data)
            {
              distribute_local_to_patch_impl(cdf);
            }
          };

          const UpdateFlags update_flags_v =
            update_values | update_gradients | update_quadrature_points | update_JxW_values;
          const UpdateFlags interface_update_flags_v = update_flags_v | update_normal_vectors;

          const UpdateFlags update_flags_sf           = update_flags_v | update_hessians;
          const UpdateFlags interface_update_flags_sf = interface_update_flags_v | update_hessians;

          ScratchData<dim, true> scratch_data_tmpl(mapping,
                                                   dofh_v.get_fe(),
                                                   dofh_sf.get_fe(),
                                                   n_q_points_1d,
                                                   *trafomatrix_orth,
                                                   update_flags_v,
                                                   update_flags_sf,
                                                   interface_update_flags_v,
                                                   interface_update_flags_sf);

          CopyData copy_data_tmpl;

          MeshWorker::m2d2::mesh_loop(
            local_cell_range_v,
            [&](const CellIterator &     cell,
                ScratchData<dim, true> & scratch_data,
                CopyData &               copy_data) {
              CellIterator cell_sf(&dofh_sf.get_triangulation(),
                                   cell->level(),
                                   cell->index(),
                                   &dofh_sf);
              CellIterator cell_p(&dofh_p.get_triangulation(),
                                  cell->level(),
                                  cell->index(),
                                  &dofh_p);
              /// compute local matrix A^\orth
              matrix_integrator.cell_residual_worker(
                cell, cell_sf, cell_p, scratch_data, copy_data);

              /// compute local rhs f^\orth (dual restriction)
              AssertDimension(copy_data.cell_data.size(), 1);
              auto &                               cd = copy_data.cell_data.back();
              std::vector<types::global_dof_index> dof_indices_v(cell->get_fe().dofs_per_cell);
              cell->get_active_or_mg_dof_indices(dof_indices_v);
              std::vector<unsigned int> local_dof_indices_v;
              std::transform(dof_indices_v.begin(),
                             dof_indices_v.end(),
                             std::back_inserter(local_dof_indices_v),
                             [&](const auto dof_index) {
                               const auto & local_index = g2l_v.find(dof_index);
                               return local_index != g2l_v.cend() ? local_index->second :
                                                                    numbers::invalid_unsigned_int;
                             });
              Vector<Number> local_rhs_v(dof_indices_v.size());
              for(auto i = 0U; i < local_rhs_v.size(); ++i)
                if(local_dof_indices_v[i] != numbers::invalid_unsigned_int)
                  local_rhs_v(i) = src_v_view[local_dof_indices_v[i]][lane];
              trafomatrix_orth->vmult(cd.rhs, local_rhs_v);
            },
            local_copier,
            scratch_data_tmpl,
            copy_data_tmpl,
            MeshWorker::assemble_own_cells | MeshWorker::assemble_ghost_cells |
              MeshWorker::assemble_boundary_faces | MeshWorker::assemble_own_interior_faces_both |
              MeshWorker::assemble_ghost_faces_both,
            /*assemble faces at ghosts?*/ true,
            [&](const CellIterator &     cell,
                const unsigned int &     face_no,
                ScratchData<dim, true> & scratch_data,
                CopyData &               copy_data) {
              CellIterator cell_sf(&dofh_sf.get_triangulation(),
                                   cell->level(),
                                   cell->index(),
                                   &dofh_sf);
              CellIterator cell_p(&dofh_p.get_triangulation(),
                                  cell->level(),
                                  cell->index(),
                                  &dofh_p);
              matrix_integrator.boundary_residual_worker_tangential(
                cell, cell_sf, cell_p, face_no, scratch_data, copy_data);
              copy_data.face_data.back().rhs *= 0.; // safety
            },
            [&](const CellIterator &     cell,
                const unsigned int &     face_no,
                const unsigned int &     sface_no,
                const CellIterator &     ncell,
                const unsigned int &     nface_no,
                const unsigned int &     nsface_no,
                ScratchData<dim, true> & scratch_data,
                CopyData &               copy_data) {
              CellIterator cell_sf(&dofh_sf.get_triangulation(),
                                   cell->level(),
                                   cell->index(),
                                   &dofh_sf);
              CellIterator cell_p(&dofh_p.get_triangulation(),
                                  cell->level(),
                                  cell->index(),
                                  &dofh_p);
              CellIterator ncell_sf(&dofh_sf.get_triangulation(),
                                    ncell->level(),
                                    ncell->index(),
                                    &dofh_sf);
              CellIterator ncell_p(&dofh_p.get_triangulation(),
                                   ncell->level(),
                                   ncell->index(),
                                   &dofh_p);
              const bool   cell_belongs_to_collection  = belongs_to_collection(cell);
              const bool   ncell_belongs_to_collection = belongs_to_collection(ncell);
              const bool   is_interface = cell_belongs_to_collection && ncell_belongs_to_collection;
              if(is_interface)
              {
                matrix_integrator.face_residual_worker_tangential(cell,
                                                                  cell_sf,
                                                                  cell_p,
                                                                  face_no,
                                                                  sface_no,
                                                                  ncell,
                                                                  ncell_sf,
                                                                  ncell_p,
                                                                  nface_no,
                                                                  nsface_no,
                                                                  scratch_data,
                                                                  copy_data);
                /// interfaces are assembled from both sides
                copy_data.face_data.back().matrix *= 0.5;
                copy_data.face_data.back().rhs *= 0.; // safety
                return;
              }
              if(cell_belongs_to_collection)
              {
                matrix_integrator.uniface_residual_worker_tangential(
                  cell, cell_sf, cell_p, face_no, sface_no, scratch_data, copy_data);
                copy_data.face_data.back().rhs *= 0.; // safety
              }
            });
        }

        /// constant pressure modes
        {
          const auto & cells_p = patch_dof_worker_p.get_cell_collection(patch_index, lane);

          const auto & local_cell_range_p = TPSS::make_local_cell_range(cells_p);

          //: setup local system (pressure constants)
          AffineConstraints<double> constraints_on_interface;
          const auto interface_index_of_fixed_cell = interface_handler.get_fixed_interface_index();
          constraints_on_interface.add_line(interface_index_of_fixed_cell);
          constraints_on_interface.set_inhomogeneity(interface_index_of_fixed_cell, 0.);
          constraints_on_interface.close();

          /// we use the same constraints on cells and interfaces
          AssertDimension(cells.size(), interface_handler.n_interfaces());
          AssertDimension(interface_handler.get_fixed_cell_index(),
                          interface_handler.get_fixed_interface_index());
          const auto & constraints_on_cell = constraints_on_interface;

          DynamicSparsityPattern dsp(interface_handler.n_interfaces());
          for(const auto & id : interface_handler.cached_interface_ids)
          {
            const auto e                 = interface_handler.get_interface_index(id);
            const auto [K_left, K_right] = interface_handler.get_cell_index_pair(id);
            dsp.add(e, K_left);
            dsp.add(e, K_right);
          }

          constraints_on_interface.condense(dsp);

          SparsityPattern sparsity_pattern;
          sparsity_pattern.copy_from(dsp);

          SparseMatrix<double> local_matrix_constp;
          local_matrix_constp.reinit(sparsity_pattern);
          Vector<double> local_rhs_constp(interface_handler.n_interfaces());
          Vector<double> local_solution_constp(cells.size());

          //: assemble prolongation matrix on this patch (pressure constants)
          FullMatrix<Number> prolongation_matrix_interface;
          prolongation_matrix_interface.reinit(n_dofs_v, cells.size());

          const auto make_active_interface_indices = [&](const CellIterator & cell) {
            return Stokes::Velocity::SIPG::MW::make_active_interface_indices_impl(interface_handler,
                                                                                  cell);
          };

          for(const auto & cell : cells)
          {
            std::vector<types::global_dof_index> dof_indices_v(cell->get_fe().dofs_per_cell);
            cell->get_active_or_mg_dof_indices(dof_indices_v);

            std::vector<unsigned int> local_dof_indices_v;
            std::transform(dof_indices_v.begin(),
                           dof_indices_v.end(),
                           std::back_inserter(local_dof_indices_v),
                           [&](const auto dof_index) {
                             const auto & local_index = g2l_v.find(dof_index);
                             return local_index != g2l_v.cend() ? local_index->second :
                                                                  numbers::invalid_unsigned_int;
                           });

            const auto & [active_face_nos, global_face_nos] = make_active_interface_indices(cell);

            for(auto ci = 0U; ci < local_dof_indices_v.size(); ++ci)
              if(local_dof_indices_v[ci] != numbers::invalid_unsigned_int)
                for(auto cj = 0U; cj < active_face_nos.size(); ++cj)
                  prolongation_matrix_interface(local_dof_indices_v[ci], global_face_nos[cj]) =
                    (*trafomatrix_orth_faces)(active_face_nos[cj], ci);
          }

          //: assemble the local residual of the Stokes system (pressure constants)
          {
            using Stokes::Velocity::SIPG::MW::ScratchData;

            using Stokes::Velocity::SIPG::MW::CopyData;

            using Stokes::Velocity::SIPG::MW::MatrixIntegrator;

            MatrixIntegrator<dim, true, is_simplified> matrix_integrator(
              nullptr, nullptr, nullptr, *equation_data, &interface_handler);

            const auto distribute_local_to_global_impl = [&](const auto & cd) {
              std::vector<unsigned int> local_dof_indices_sf;
              std::transform(cd.dof_indices_column.begin(),
                             cd.dof_indices_column.end(),
                             std::back_inserter(local_dof_indices_sf),
                             [&](const auto dof_index) {
                               const auto & local_index = g2l_sf.find(dof_index);
                               return local_index != g2l_sf.cend() ? local_index->second :
                                                                     numbers::invalid_unsigned_int;
                             });

              AssertDimension(local_dof_indices_sf.size(), cd.matrix.n());
              Vector<Number> local_solution_sf(cd.matrix.n());
              for(auto i = 0U; i < local_solution_sf.size(); ++i)
                if(local_dof_indices_sf[i] != numbers::invalid_unsigned_int)
                  local_solution_sf(i) = solution_sf[local_dof_indices_sf[i]][lane];

              Vector<Number> Ax(cd.matrix.m());
              cd.matrix.vmult(Ax, local_solution_sf);

              constraints_on_interface.template distribute_local_to_global(Ax,
                                                                           cd.dof_indices,
                                                                           local_rhs_constp);
            };

            const auto local_copier = [&](const CopyData & copy_data) {
              for(const auto & cd : copy_data.cell_data)
                distribute_local_to_global_impl(cd);
              for(const auto & cdf : copy_data.face_data)
                distribute_local_to_global_impl(cdf);
            };

            const UpdateFlags update_flags_v =
              update_values | update_gradients | update_quadrature_points | update_JxW_values;
            const UpdateFlags interface_update_flags_v = update_values | update_gradients |
                                                         update_quadrature_points |
                                                         update_JxW_values | update_normal_vectors;

            const UpdateFlags update_flags_sf = update_flags_v | update_hessians;
            const UpdateFlags interface_update_flags_sf =
              interface_update_flags_v | update_hessians;

            ScratchData<dim, true> scratch_data(mapping,
                                                dofh_v.get_fe(),
                                                dofh_sf.get_fe(),
                                                n_q_points_1d,
                                                *trafomatrix_orth_faces,
                                                update_flags_v,
                                                update_flags_sf,
                                                interface_update_flags_v,
                                                interface_update_flags_sf);

            CopyData copy_data;

            MeshWorker::m2d2::mesh_loop(
              local_cell_range_v,
              [&](const CellIterator &     cell,
                  ScratchData<dim, true> & scratch_data,
                  CopyData &               copy_data) {
                CellIterator cell_sf(&dofh_sf.get_triangulation(),
                                     cell->level(),
                                     cell->index(),
                                     &dofh_sf);
                /// compute local matrix A^\orth
                matrix_integrator.cell_residual_worker_interface(cell,
                                                                 cell_sf,
                                                                 scratch_data,
                                                                 copy_data);
              },
              local_copier,
              scratch_data,
              copy_data,
              MeshWorker::assemble_own_cells | MeshWorker::assemble_ghost_cells |
                MeshWorker::assemble_boundary_faces | MeshWorker::assemble_own_interior_faces_both |
                MeshWorker::assemble_ghost_faces_both,
              /*assemble faces at ghosts?*/ true,
              [&](const CellIterator &     cell,
                  const unsigned int &     face_no,
                  ScratchData<dim, true> & scratch_data,
                  CopyData &               copy_data) {
                CellIterator cell_sf(&dofh_sf.get_triangulation(),
                                     cell->level(),
                                     cell->index(),
                                     &dofh_sf);
                matrix_integrator.boundary_residual_worker_tangential_interface(
                  cell, cell_sf, face_no, scratch_data, copy_data);
              },
              [&](const CellIterator &     cell,
                  const unsigned int &     face_no,
                  const unsigned int &     sface_no,
                  const CellIterator &     ncell,
                  const unsigned int &     nface_no,
                  const unsigned int &     nsface_no,
                  ScratchData<dim, true> & scratch_data,
                  CopyData &               copy_data) {
                CellIterator cell_sf(&dofh_sf.get_triangulation(),
                                     cell->level(),
                                     cell->index(),
                                     &dofh_sf);
                CellIterator ncell_sf(&dofh_sf.get_triangulation(),
                                      ncell->level(),
                                      ncell->index(),
                                      &dofh_sf);
                const bool   cell_belongs_to_collection  = belongs_to_collection(cell);
                const bool   ncell_belongs_to_collection = belongs_to_collection(ncell);
                const bool is_interface = cell_belongs_to_collection && ncell_belongs_to_collection;
                if(is_interface)
                {
                  matrix_integrator.face_residual_worker_tangential_interface(cell,
                                                                              cell_sf,
                                                                              face_no,
                                                                              sface_no,
                                                                              ncell,
                                                                              ncell_sf,
                                                                              nface_no,
                                                                              nsface_no,
                                                                              scratch_data,
                                                                              copy_data);
                  /// interfaces are assembled from both sides
                  copy_data.face_data.back().matrix *= 0.5;
                  return;
                }
                if(cell_belongs_to_collection)
                {
                  matrix_integrator.uniface_residual_worker_tangential_interface(
                    cell, cell_sf, face_no, sface_no, scratch_data, copy_data);
                }
              });

            /// compute the residual for this patch
            local_rhs_constp *= -1.; // -Ax
            const auto local_rhs_v = array_view_to_vector(src_v_view, lane);
            prolongation_matrix_interface.Tvmult_add(local_rhs_constp, local_rhs_v); // f - Ax
          }

          //: assemble the local matrix and right-hand side (pressure constants)
          {
            using Biharmonic::Pressure::Interface::MW::ScratchData;

            using Biharmonic::Pressure::Interface::MW::CopyData;

            using Biharmonic::Pressure::Interface::MW::MatrixIntegrator;

            ArrayView<const VectorizedArray<double>> dst_p_cview = make_array_view(dst_p_view);

            MatrixIntegrator<dim, true> matrix_integrator(
              nullptr, &interface_handler, *equation_data, &g2l_p, &dst_p_cview, lane);

            const auto local_copier = [&](const CopyData & copy_data) {
              for(const auto & cdf : copy_data.face_data)
              {
                constraints_on_interface.template distribute_local_to_global<Vector<double>>(
                  cdf.rhs, cdf.dof_indices, local_rhs_constp);

                constraints_on_interface.template distribute_local_to_global<SparseMatrix<double>>(
                  cdf.matrix,
                  cdf.dof_indices,
                  constraints_on_cell,
                  cdf.dof_indices_column,
                  local_matrix_constp);
              }
            };

            const UpdateFlags update_flags_v =
              update_values | update_quadrature_points | update_JxW_values;
            const UpdateFlags interface_update_flags_v = update_flags_v | update_normal_vectors;

            const UpdateFlags update_flags_p = update_default;
            const UpdateFlags interface_update_flags_p =
              update_values | update_quadrature_points | update_JxW_values | update_normal_vectors;

            ScratchData<dim> scratch_data(mapping,
                                          dofh_v.get_fe(),
                                          dofh_p.get_fe(),
                                          n_q_points_1d,
                                          *trafomatrix_orth_faces,
                                          update_flags_v,
                                          update_flags_p,
                                          interface_update_flags_v,
                                          interface_update_flags_p);

            CopyData copy_data;

            MeshWorker::m2d2::mesh_loop(
              local_cell_range_v,
              /*cell_worker*/ nullptr,
              local_copier,
              scratch_data,
              copy_data,
              MeshWorker::assemble_own_interior_faces_both | MeshWorker::assemble_ghost_faces_both,
              /*assemble faces at ghosts?*/ true,
              /*boundary_worker*/ nullptr,
              [&](const auto & cell,
                  const auto   face_no,
                  const auto   sface_no,
                  const auto & ncell,
                  const auto   nface_no,
                  const auto   nsface_no,
                  auto &       scratch_data,
                  auto &       copy_data) {
                const bool cell_belongs_to_collection  = belongs_to_collection(cell);
                const bool ncell_belongs_to_collection = belongs_to_collection(ncell);
                const bool is_interface = cell_belongs_to_collection && ncell_belongs_to_collection;
                if(is_interface)
                {
                  CellIterator cellP(&dofh_p.get_triangulation(),
                                     cell->level(),
                                     cell->index(),
                                     &dofh_p);
                  CellIterator ncellP(&dofh_p.get_triangulation(),
                                      ncell->level(),
                                      ncell->index(),
                                      &dofh_p);
                  const bool   was_assembled = matrix_integrator.face_worker(cell,
                                                                           cellP,
                                                                           face_no,
                                                                           sface_no,
                                                                           ncell,
                                                                           ncellP,
                                                                           nface_no,
                                                                           nsface_no,
                                                                           scratch_data,
                                                                           copy_data);
                  if(was_assembled)
                  {
                    copy_data.face_data.back().matrix *= 0.5; /// both sides!
                    copy_data.face_data.back().rhs *= 0.5;    /// both sides!
                  }
                }
              });
          }

          //: solve the local system (pressure constants)
          constraints_on_interface.condense(local_matrix_constp, local_rhs_constp);

          SparseDirectUMFPACK A_direct;
          A_direct.template initialize<SparseMatrix<double>>(local_matrix_constp);
          A_direct.vmult(local_solution_constp, local_rhs_constp);

          constraints_on_interface.distribute(local_solution_constp);

          //: distribute the pressure constants to the local pressure solution
          {
            std::vector<types::global_dof_index> dof_indices(dofh_p.get_fe().dofs_per_cell);
            for(const auto & cell_p : cells_p)
            {
              cell_p->get_active_or_mg_dof_indices(dof_indices);
              const auto local_dof_index        = g2l_p.at(dof_indices.front());
              const auto cell_index             = interface_handler.get_cell_index(cell_p->id());
              dst_p_view[local_dof_index][lane] = local_solution_constp(cell_index);
            }
          }

          /// post-process local pressure
          {
            using ::MW::ScratchData;
            using ::MW::Cell::CopyData;

            double mean_value = 0.;
            double volume     = 0.;

            const auto local_copier = [&](const CopyData & copy_data) {
              for(const auto & cd : copy_data.cell_data)
              {
                mean_value += cd.values(0);
                volume += cd.values(1);
              }
            };

            const UpdateFlags update_flags_p =
              update_values | update_quadrature_points | update_JxW_values;

            ScratchData<dim> scratch_data(mapping, dofh_p.get_fe(), n_q_points_1d, update_flags_p);

            CopyData copy_data;

            MeshWorker::m2d2::mesh_loop(
              local_cell_range_p,
              [&](const auto & cell, auto & scratch_data, auto & copy_data) {
                auto & phi = scratch_data.fe_values;
                phi.reinit(cell);

                const unsigned int n_dofs = cell->get_fe().dofs_per_cell;

                std::vector<types::global_dof_index> dof_indices(n_dofs);
                cell->get_active_or_mg_dof_indices(dof_indices);

                std::vector<unsigned int> local_dof_indices;
                std::transform(dof_indices.begin(),
                               dof_indices.end(),
                               std::back_inserter(local_dof_indices),
                               [&](const auto dof_index) {
                                 const auto & local_index = g2l_p.find(dof_index);
                                 return local_index != g2l_p.cend() ? local_index->second :
                                                                      numbers::invalid_unsigned_int;
                               });

                Vector<double> dof_values(n_dofs);
                for(auto i = 0U; i < n_dofs; ++i)
                  if(local_dof_indices[i] != numbers::invalid_unsigned_int)
                    dof_values(i) = dst_p_view[local_dof_indices[i]][lane];

                const auto & compute_value = [&](const unsigned int q) {
                  double value = 0.;
                  for(auto j = 0U; j < n_dofs; ++j)
                    value += dof_values[j] * phi.shape_value(j, q);
                  return value;
                };

                auto & cd = copy_data.cell_data.emplace_back(2U);

                for(auto q = 0U; q < phi.n_quadrature_points; ++q)
                {
                  const auto & dx      = phi.JxW(q);
                  const auto & value_p = compute_value(q);
                  cd.values(0) += value_p * dx;
                  cd.values(1) += dx;
                }
              },
              local_copier,
              scratch_data,
              copy_data,
              MeshWorker::assemble_own_cells | MeshWorker::assemble_ghost_cells);

            /// make the local pressure solution mean-value-free
            for(const auto & cell_p : cells_p)
            {
              std::vector<types::global_dof_index> dof_indices(cell_p->get_fe().dofs_per_cell);
              cell_p->get_active_or_mg_dof_indices(dof_indices);
              dst_p_view[g2l_p.at(dof_indices.front())][lane] -= mean_value / volume;
            }
          }
        }
      } // loop over lanes
    }
  }

  std::shared_ptr<transfer_type>
  get_patch_transfer(const SubdomainHandler<dim, Number> & subdomain_handler) const
  {
    std::vector<const TPSS::DoFInfo<dim, Number> *> dofinfos;
    dofinfos.push_back(&subdomain_handler.get_dof_info(0));
    dofinfos.push_back(&subdomain_handler.get_dof_info(1));
    return std::make_shared<transfer_type>(dofinfos);
  }

  std::shared_ptr<transfer_type_stream>
  get_patch_transfer_stream(const SubdomainHandler<dim, Number> & subdomain_handler) const
  {
    return std::make_shared<transfer_type_stream>(subdomain_handler, 2);
  }
};



/**
 * This class makes no use of fast diagonalization but simply uses the
 * MeshWorker framework to assemble local matrices: Actually, we assemble only
 * local C0IP-like matrices to obtain local div-free velocities. Local pressures
 * are reconstructed from these in a two-step process... PatchTransfers are used
 * to transfer stream function, velocity and pressure coefficients. Underlying
 * PatchDoFWorkers determine collections of cell iterators passed to
 * mesh_loop().
 *
 * Therefore, all local matrices are stored and inverted in a standard way, that
 * is without exploiting any tensor structure.
 */
template<int dim, int fe_degree_p, typename Number = double, bool is_simplified = false>
class MatrixIntegratorStream
{
public:
  using This = MatrixIntegratorStream<dim, fe_degree_p, Number, is_simplified>;

  static constexpr TPSS::DoFLayout dof_layout_v  = TPSS::DoFLayout::RT;
  static constexpr int             fe_degree_v   = fe_degree_p;
  static constexpr int             n_q_points_1d = n_q_points_1d_impl(fe_degree_v, dof_layout_v);

  using value_type           = Number;
  using matrix_type          = LocalSolverStream<dim, Number, is_simplified>;
  using transfer_type        = typename matrix_type::transfer_type;
  using transfer_type_stream = typename matrix_type::transfer_type_stream;
  using operator_type        = TrilinosWrappers::BlockSparseMatrix;

  void
  initialize(const EquationData & equation_data_in)
  {
    equation_data = equation_data_in;
  }

  void
  assemble_subspace_inverses(const SubdomainHandler<dim, Number> & subdomain_handler,
                             std::vector<matrix_type> &            local_matrices,
                             const operator_type & /*level_matrix*/,
                             const std::pair<unsigned int, unsigned int> subdomain_range) const
  {
    AssertDimension(subdomain_handler.get_partition_data().n_subdomains(), local_matrices.size());
    AssertDimension(subdomain_handler.n_dof_handlers(), 3U);

    const auto & dofh_v  = subdomain_handler.get_dof_handler(0);
    const auto & dofh_p  = subdomain_handler.get_dof_handler(1);
    const auto & dofh_sf = subdomain_handler.get_dof_handler(2);

    const auto   patch_transfer_sf   = get_patch_transfer_stream(subdomain_handler);
    const auto & patch_dof_worker_sf = patch_transfer_sf->get_patch_dof_worker();

    const auto & [shape_to_test_functions_interior, shape_to_test_functions_faces] =
      compute_divfreeorth_shape_functions(dofh_v.get_fe(), dofh_p.get_fe());

    const auto prolong_sf =
      std::make_shared<const ProlongationStream<dim, Number>>(dofh_sf.get_fe(), dofh_v.get_fe());
    const auto velocity_to_orth =
      std::make_shared<const FullMatrix<Number>>(shape_to_test_functions_interior);
    const auto velocity_to_orth_faces =
      std::make_shared<const FullMatrix<Number>>(shape_to_test_functions_faces);

    FullMatrix<double> tmp;

    const auto [begin, end] = subdomain_range;
    for(auto patch_index = begin; patch_index < end; ++patch_index)
    {
      patch_transfer_sf->reinit(patch_index);

      const auto n_dofs_stream = patch_transfer_sf->n_dofs_per_patch();

      matrix_type & patch_matrix = local_matrices[patch_index];

      patch_matrix.subdomain_handler = &subdomain_handler;
      patch_matrix.patch_index       = patch_index;
      patch_matrix.n_q_points_1d     = n_q_points_1d;
      patch_matrix.equation_data     = &equation_data;

      patch_matrix.solver_sf.as_table().reinit(n_dofs_stream, n_dofs_stream);
      tmp.reinit(n_dofs_stream, n_dofs_stream);

      for(auto lane = 0U; lane < patch_dof_worker_sf.n_lanes_filled(patch_index); ++lane)
      {
        /// biharmonic solver (div-free velocity)
        {
          using Velocity::SIPG::MW::CopyData;

          using Velocity::SIPG::MW::ScratchData;

          using MatrixIntegrator = Velocity::SIPG::MW::MatrixIntegrator<dim, true, is_simplified>;

          using cell_iterator_type = typename MatrixIntegrator::IteratorType;

          tmp = 0.;

          const auto & cell_collection = patch_dof_worker_sf.get_cell_collection(patch_index, lane);

          const TPSS::BelongsToCollection<cell_iterator_type> belongs_to_collection(
            cell_collection);

          const auto & local_cell_range = TPSS::make_local_cell_range(cell_collection);

          const auto & g2l = patch_transfer_sf->get_global_to_local_dof_indices(lane);

          const auto distribute_local_to_patch_impl = [&](const auto & cd) {
            std::vector<unsigned int> local_dof_indices;
            std::transform(cd.dof_indices.begin(),
                           cd.dof_indices.end(),
                           std::back_inserter(local_dof_indices),
                           [&](const auto dof_index) {
                             const auto & local_index = g2l.find(dof_index);
                             return local_index != g2l.cend() ? local_index->second :
                                                                numbers::invalid_unsigned_int;
                           });
            for(auto i = 0U; i < cd.matrix.m(); ++i)
              if(local_dof_indices[i] != numbers::invalid_unsigned_int)
                for(auto j = 0U; j < cd.matrix.n(); ++j)
                  if(local_dof_indices[j] != numbers::invalid_unsigned_int)
                    tmp(local_dof_indices[i], local_dof_indices[j]) += cd.matrix(i, j);
          };

          const auto local_copier = [&](const CopyData & copy_data) {
            for(const auto & cd : copy_data.cell_data)
              distribute_local_to_patch_impl(cd);
            for(const auto & cdf : copy_data.face_data)
              distribute_local_to_patch_impl(cdf);
          };

          const MatrixIntegrator matrix_integrator(nullptr, nullptr, nullptr, equation_data);

          const UpdateFlags update_flags = update_values | update_gradients | update_hessians |
                                           update_quadrature_points | update_JxW_values;
          const UpdateFlags interface_update_flags = update_flags | update_normal_vectors;

          ScratchData<dim> scratch_data(subdomain_handler.get_mapping(),
                                        subdomain_handler.get_dof_handler(2).get_fe(),
                                        subdomain_handler.get_dof_handler(2).get_fe(),
                                        n_q_points_1d,
                                        update_flags,
                                        update_flags,
                                        interface_update_flags,
                                        interface_update_flags);

          CopyData copy_data;

          MeshWorker::m2d2::mesh_loop(
            local_cell_range,
            [&](const auto & cell, auto & scratch_data, auto & copy_data) {
              matrix_integrator.cell_worker_stream(cell, scratch_data, copy_data);
            },
            local_copier,
            scratch_data,
            copy_data,
            MeshWorker::assemble_own_cells | MeshWorker::assemble_ghost_cells |
              MeshWorker::assemble_boundary_faces | MeshWorker::assemble_own_interior_faces_both |
              MeshWorker::assemble_ghost_faces_both,
            /*assemble faces at ghosts?*/ true,
            [&](const auto & cell, const auto face_no, auto & scratch_data, auto & copy_data) {
              // matrix_integrator.boundary_worker_stream(cell, face_no, scratch_data, copy_data);
              matrix_integrator.boundary_worker_tangential_stream(cell,
                                                                  face_no,
                                                                  scratch_data,
                                                                  copy_data); // !!!
            },
            [&](const auto & cell,
                const auto   face_no,
                const auto   sface_no,
                const auto & ncell,
                const auto   nface_no,
                const auto   nsface_no,
                auto &       scratch_data,
                auto &       copy_data) {
              const bool cell_belongs_to_collection  = belongs_to_collection(cell);
              const bool ncell_belongs_to_collection = belongs_to_collection(ncell);
              const bool is_interface = cell_belongs_to_collection && ncell_belongs_to_collection;
              if(is_interface)
              {
                /// TODO face_worker_tangential_stream ?
                matrix_integrator.face_worker_stream(
                  cell, face_no, sface_no, ncell, nface_no, nsface_no, scratch_data, copy_data);
                copy_data.face_data.back().matrix *= 0.5; /// both sides!
                return;
              }
              if(cell_belongs_to_collection)
              {
                /// TODO uniface_worker_tangential_stream ?
                matrix_integrator.uniface_worker_stream(
                  cell, face_no, sface_no, scratch_data, copy_data);
              }
            });
        }

        patch_matrix.solver_sf.fill_submatrix(tmp, 0U, 0U, lane);
      }

      AssertDimension(patch_matrix.solver_sf.m(), n_dofs_stream);
      AssertDimension(patch_matrix.solver_sf.n(), n_dofs_stream);

      patch_matrix.solver_sf.invert();

      /// caching prolongation: from stream to velocity
      patch_matrix.prolongation_sf = prolong_sf;

      /// caching transformation matrices: orth. velocity functions
      patch_matrix.trafomatrix_orth       = velocity_to_orth;
      patch_matrix.trafomatrix_orth_faces = velocity_to_orth_faces;
    }
  }

  std::shared_ptr<transfer_type>
  get_patch_transfer(const SubdomainHandler<dim, Number> & subdomain_handler) const
  {
    std::vector<const TPSS::DoFInfo<dim, Number> *> dofinfos;
    dofinfos.push_back(&subdomain_handler.get_dof_info(0));
    dofinfos.push_back(&subdomain_handler.get_dof_info(1));
    return std::make_shared<transfer_type>(dofinfos);
  }

  std::shared_ptr<transfer_type_stream>
  get_patch_transfer_stream(const SubdomainHandler<dim, Number> & subdomain_handler) const
  {
    return std::make_shared<transfer_type_stream>(subdomain_handler, 2);
  }

  EquationData equation_data;
};

} // namespace LMW



/**
 * Selects the MatrixIntegrator at compile time w.r.t. the template parameter @p
 * local_assembly. Hence, the generic class is empty and we select by template
 * specialization.
 */
template<LocalAssembly local_assembly,
         int           dim,
         int           fe_degree_p,
         typename Number,
         TPSS::DoFLayout dof_layout_v,
         int             fe_degree_v,
         bool            is_simplified>
struct MatrixIntegratorSelector
{
};

template<int dim,
         int fe_degree_p,
         typename Number,
         TPSS::DoFLayout dof_layout_v,
         int             fe_degree_v,
         bool            is_simplified>
struct MatrixIntegratorSelector<LocalAssembly::Tensor,
                                dim,
                                fe_degree_p,
                                Number,
                                dof_layout_v,
                                fe_degree_v,
                                is_simplified>
{
  using type = FD::MatrixIntegrator<dim, fe_degree_p, Number, dof_layout_v, fe_degree_v>;
};

template<int dim,
         int fe_degree_p,
         typename Number,
         TPSS::DoFLayout dof_layout_v,
         int             fe_degree_v,
         bool            is_simplified>
struct MatrixIntegratorSelector<LocalAssembly::Cut,
                                dim,
                                fe_degree_p,
                                Number,
                                dof_layout_v,
                                fe_degree_v,
                                is_simplified>
{
  using type = MatrixIntegratorCut<dim, fe_degree_p, Number, dof_layout_v, fe_degree_v>;
};

template<int dim,
         int fe_degree_p,
         typename Number,
         TPSS::DoFLayout dof_layout_v,
         int             fe_degree_v,
         bool            is_simplified>
struct MatrixIntegratorSelector<LocalAssembly::LMW,
                                dim,
                                fe_degree_p,
                                Number,
                                dof_layout_v,
                                fe_degree_v,
                                is_simplified>
{
  using type =
    LMW::MatrixIntegrator<dim, fe_degree_p, Number, dof_layout_v, fe_degree_v, is_simplified>;
};

template<int dim,
         int fe_degree_p,
         typename Number,
         TPSS::DoFLayout dof_layout_v,
         int             fe_degree_v,
         bool            is_simplified>
struct MatrixIntegratorSelector<LocalAssembly::StreamLMW,
                                dim,
                                fe_degree_p,
                                Number,
                                dof_layout_v,
                                fe_degree_v,
                                is_simplified>
{
  static_assert(dof_layout_v == TPSS::DoFLayout::RT, "Implemented for Raviart-Thomas.");
  static_assert(fe_degree_p == fe_degree_v, "Mismatching finite element degrees.");
  using type = LMW::MatrixIntegratorStream<dim, fe_degree_p, Number, is_simplified>;
};



/**
 * Aliasing MatrixIntegrator w.r.t. the choice of LocalAssembly.
 */
template<int dim,
         int fe_degree_p,
         typename Number                = double,
         TPSS::DoFLayout dof_layout_v   = TPSS::DoFLayout::Q,
         int             fe_degree_v    = fe_degree_p + 1,
         LocalAssembly   local_assembly = LocalAssembly::Tensor,
         bool            is_simplified  = false>
using MatrixIntegrator = typename MatrixIntegratorSelector<local_assembly,
                                                           dim,
                                                           fe_degree_p,
                                                           Number,
                                                           dof_layout_v,
                                                           fe_degree_v,
                                                           is_simplified>::type;

} // namespace VelocityPressure

} // namespace Stokes

#endif /* APPS_STOKESINTEGRATOR_H_ */
